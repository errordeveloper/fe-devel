<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8">  
  <!--
    Copyright 2010-2011 Fabric Technologies Inc. All rights reserved.
    -->
    <title>FABRIC - Alembic Animation Review Tool</title> 
    
    <link type="text/css" href="../../../../ThirdParty/jQuery/css/fabric/main.css" rel="stylesheet" />
    <link type="text/css" href="../../../../ThirdParty/jQuery/css/fabric/jquery-ui-1.8.16.custom.css" rel="stylesheet" />
    
    <link href="../../../../ThirdParty/jQuery/colorpicker/css/colorpicker.css" rel="stylesheet" type="text/css" />

    <script type="text/javascript" src="../../../../ThirdParty/jQuery/jquery-1.6.2.min.js"></script>
    <script type="text/javascript" src="../../../../ThirdParty/jQuery/jquery-ui-1.8.16.custom.min.js"></script>
    <script type="text/javascript" src="../../../../ThirdParty/jQuery/colorpicker/js/colorpicker.js"></script>

    <script type="text/javascript" src="../../../../Core/FABRIC.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/Math.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/Vec2.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/Vec3.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/Vec4.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/Mat22.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/Mat33.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/Mat44.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/Quat.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/Xfo.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/RGBA.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/Color.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/Euler.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/OGLShaderProgram.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/OGLTexture2D.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/OGLBuffer.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/OGLRenderTarget.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/RT/Ray.js" charset="utf-8"></script>

    <script type="text/javascript" src="../../../../SceneGraph/FABRIC.SceneGraph.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/FABRIC.SceneGraph.Geometry.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/FABRIC.SceneGraph.Primitives.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/FABRIC.SceneGraph.Lights.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/FABRIC.SceneGraph.Images.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/FABRIC.SceneGraph.Materials.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/FABRIC.SceneGraph.Manipulation.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/FABRIC.SceneGraph.Kinematics.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/FABRIC.SceneGraph.Animation.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/FABRIC.SceneGraph.Alembic.js" charset="utf-8"></script>
    <script type="text/javascript" src="../../../../SceneGraph/FABRIC.SceneGraph.Rendering.js" charset="utf-8"></script>

    <style type="text/css">
    
#sidebar {
  width:400px;
}  
#viewer {
  right:400px;
  bottom:125px;
}
#timeControls {
  right:390px;
}


  
  </style>
    
    <script type="text/javascript">
FABRIC.SceneGraph.registerNodeType('UVViewport', {
  factoryFn: function(options, scene) {
    scene.assignDefaults(options, {
      eventName: 'UVDraw'
    });
    
    // create the offscreennode and the uv material
    var offscreenNode = scene.constructNode('OffscreenViewport', options);
    offscreenNode.pub.constructMaterial('FlatUVMaterial');
    
    // create the member to be able to query
    var dgnode = offscreenNode.getDGNode();
    dgnode.addMember('queryToggle','Boolean', false);
    dgnode.addMember('queryPos','Vec2');
    dgnode.addMember('querySize','Vec2', new FABRIC.RT.Vec2(1,1));
    dgnode.addMember('queryPixels','Color[]');
    /*
    dgnode.bindings.append(scene.constructOperator({
      operatorName: 'getRGBAPixelsFromRenderTarget',
      entryFunctionName: 'getRGBAPixelsFromRenderTarget',
      srcFile: 'FABRIC_ROOT/SceneGraph/KL/renderTarget.kl',
      parameterLayout: [
        'self.queryToggle',
        'self.renderTarget',
        'self.queryPos',
        'self.querySize',
        'self.queryPixels',
      ],
      mainThreadOnly: true
    }));
    */
    
    dgnode.addMember('allPixels','Color[]');
    var redrawEventHandler = offscreenNode.getRedrawEventHandler();
    redrawEventHandler.postDescendBindings.insert(scene.constructOperator({
      operatorName: 'getAllRGBAPixelsFromRenderTarget',
      entryFunctionName: 'getAllRGBAPixelsFromRenderTarget',
      srcFile: 'FABRIC_ROOT/SceneGraph/KL/renderTarget.kl',
      parameterLayout: [
        'data.renderTarget',
        'data.allPixels',
      ]
    }), 0);
    
    dgnode.bindings.append(scene.constructOperator({
      operatorName: 'lookupUVPixels',
      entryFunctionName: 'lookupUVPixels',
      srcFile: 'KL/AnimationReview.kl',
      parameterLayout: [
        'self.renderTarget',
        'self.queryPos',
        'self.querySize',
        'self.allPixels',
        'self.queryPixels',
      ]
    }));

    offscreenNode.addMemberInterface(dgnode, 'queryToggle', true);
    offscreenNode.addMemberInterface(dgnode, 'queryPos', true);
    offscreenNode.addMemberInterface(dgnode, 'querySize', true);
    offscreenNode.addMemberInterface(dgnode, 'queryPixels', false);
    
    return offscreenNode;
  }});


var uvPlaneGeometry;

FABRIC.SceneGraph.registerNodeType('pngEncodeEventNode', {
  factoryFn: function(options, scene) {
    scene.assignDefaults(options, {
    });

    var pngEncodeEventNode = scene.constructNode('SceneGraphNode', {name: 'pngEncodeEventNode'});
    var eventNode = pngEncodeEventNode.constructEventNode('pngEncode');
    var eventHandlerNode = pngEncodeEventNode.constructEventHandlerNode('Encode');
    eventNode.appendEventHandler(eventHandlerNode);
    
    pngEncodeEventNode.getEventHandler = function() {
      return eventHandlerNode;
    };

    pngEncodeEventNode.pub.fire = function() {
      return eventNode.fire();
    };

    return pngEncodeEventNode;    
  }});    

FABRIC.SceneGraph.registerNodeType('PaintPlaneInstance', {
  factoryFn: function(options, scene) {
    scene.assignDefaults(options, {
      viewportNode: undefined,
      uvViewportNode: undefined,
      planeNode: undefined,
      animationControllerNode: undefined,
      planeTime: 0.0,
      planeBlend: 5.0 / 30.0,
      resolutionFactor: 0.25,
      paintColor: FABRIC.RT.rgba(255,0,0,130),
      paintRadius: 1,
      planeDistance: 10.0,
      encodeEventNode: undefined,
      path: undefined
    });

    // check all of our required nodes
    if (!options.viewportNode) {
      throw ('viewportNode not specified');
    }
    var viewportNode = scene.getPrivateInterface(options.viewportNode);
    if(!viewportNode.pub.isTypeOf('Viewport')) {
      throw('viewportNode is not of type Viewport!');
    }
    if (!options.uvViewportNode) {
      throw ('uvViewportNode not specified');
    }
    var uvViewportNode = scene.getPrivateInterface(options.uvViewportNode);
    if(!uvViewportNode.pub.isTypeOf('UVViewport')) {
      throw('uvViewportNode is not of type UVViewport!');
    }
    var cameraNode = scene.getPrivateInterface(viewportNode.pub.getCameraNode());
    if(!cameraNode.pub.isTypeOf('Camera')) {
      throw('cameraNode is not of type Camera!');
    }
    var cameraTransformNode = scene.getPrivateInterface(cameraNode.pub.getTransformNode());
    if (!options.planeNode) {
      throw ('planeNode not specified');
    }
    var planeNode = scene.getPrivateInterface(options.planeNode);
    if(!planeNode.pub.isTypeOf('Plane')) {
      throw('planeNode is not of type Plane!');
    }
    if (!options.animationControllerNode) {
      throw ('animationControllerNode not specified');
    }
    var animationControllerNode = scene.getPrivateInterface(options.animationControllerNode);
    if(!animationControllerNode.pub.isTypeOf('AnimationController')) {
      throw('animationControllerNode is not of type AnimationController!');
    }
    if (!options.encodeEventNode) {
      throw ('encodeEventNode not specified');
    }
    var encodeEventNode = scene.getPrivateInterface(options.encodeEventNode);
    if(!encodeEventNode.pub.isTypeOf('pngEncodeEventNode')) {
      throw('encodeEventNode is not of type pngEncodeEventNode!');
    }
    
    // get the center of the triangles object
    var parentTransformNode = cameraNode.pub.getTransformNode();
    var planeXfo = options.transform;
    var widthPixels = 0;
    var heightPixels = 0;
    if(!planeXfo) {
      var cameraXfo = cameraTransformNode.pub.getGlobalXfo();
      var center = new FABRIC.RT.Vec3(0,0,-options.planeDistance);
      var planeXfo = cameraXfo.multiply(new FABRIC.RT.Xfo({
        tr: center,
        ori: new FABRIC.RT.Quat().setFromAxisAndAngle(new FABRIC.RT.Vec3(1,0,0), Math.HALF_PI)
      }));

      // compute the width and height of the plane
      var fovY = cameraNode.pub.getFovY();
      var height = 1.95 * Math.abs(center.z) * Math.tan(fovY * 0.5);
      widthPixels = $('#FabricContainer').width();
      heightPixels = $('#FabricContainer').height();
      var aspect = widthPixels / heightPixels;
      var width = height * aspect;
      planeXfo.sc.x = width;
      planeXfo.sc.z = height;
      
      parentTransform = parentTransformNode.getGlobalXfo();
      planeXfo = parentTransform.inverse().multiply(planeXfo);

      widthPixels = parseInt(widthPixels * options.resolutionFactor);
      heightPixels = parseInt(heightPixels * options.resolutionFactor);
    }
    
    // create a transform node for the plane
    var transformNode = scene.constructNode('Transform', {
      hierarchical: true,
      parentTransformNode: parentTransformNode,
      localXfo: planeXfo
    });

    // create a texture to paint onto
    var textureNode = scene.constructNode('Image2D', {
      createDgNodes: true,
      createResourceLoadNode: false,
      width: widthPixels,
      height: heightPixels,
      forceRefresh: true
    });
    var textureuniformsdgnode = textureNode.getUniformsDGNode();
    var texturepixelsdgnode = textureNode.getPixelsDGNode();
    
    // now check if we eventually need to load an existing resource
    if(options.path) {
      textureuniformsdgnode.addMember('resource','FabricResource');
      textureuniformsdgnode.getResourceFromFile('resource', options.path);
      
      // add a decoder for this image
      texturepixelsdgnode.bindings.append(scene.constructOperator({
        operatorName: 'loadImageRGBA',
        entryFunctionName: 'loadImageRGBA',
        srcFile: 'FABRIC_ROOT/SceneGraph/KL/loadTexture.kl',
        preProcessorDefinitions: { PIXELFORMAT: 'RGBA' },
        parameterLayout: [
          'uniforms.resource',
          'uniforms.width',
          'uniforms.height',
          'uniforms.pixels',
          'self.newCount'
        ]
      }));
      texturepixelsdgnode.bindings.append(scene.constructOperator({
        operatorName: 'sliceImageRGBA',
        parameterLayout: [
          'self.index',
          'uniforms.pixels',
          'self.pixels'
        ],
        preProcessorDefinitions: { PIXELFORMAT: 'RGBA' },
        entryFunctionName: 'sliceImageRGBA',
        srcFile: 'FABRIC_ROOT/SceneGraph/KL/loadTexture.kl'
      }));
      texturepixelsdgnode.bindings.append(scene.constructOperator({
        operatorName: 'clearImageRGBA',
        parameterLayout: [
          'uniforms.pixels'
        ],
        preProcessorDefinitions: { PIXELFORMAT: 'RGBA' },
        entryFunctionName: 'clearImageRGBA',
        srcFile: 'FABRIC_ROOT/SceneGraph/KL/loadTexture.kl'
      }));
    }
    
    // create the paint operator for the texture
    textureuniformsdgnode.addMember('paint','Integer',0);
    textureuniformsdgnode.addMember('paintColor','RGBA',options.paintColor);
    textureuniformsdgnode.addMember('paintErase','Boolean',false);
    textureuniformsdgnode.addMember('paintRadius','Scalar',options.paintRadius);
    textureuniformsdgnode.addMember('prevUVs','Color[]',[]);
    texturepixelsdgnode.setDependency(uvViewportNode.getDGNode(),'uvviewport');
    texturepixelsdgnode.bindings.append(scene.constructOperator({
      operatorName: 'paintPixels',
      entryFunctionName: 'paintPixels',
      srcFile: 'KL/AnimationReview.kl',
      parameterLayout: [
        'uniforms.paint',
        'uniforms.paintErase',
        'uniforms.paintColor',
        'uniforms.paintRadius',
        'uniforms.width',
        'uniforms.height',
        'self.pixels<>',
        'uvviewport.queryPixels',
        'uniforms.prevUVs'
      ]
    }));

    // create a frame operator to the texture
    textureuniformsdgnode.addMember('drawFrame','Boolean',true);
    textureuniformsdgnode.addMember('frameColor','RGBA',FABRIC.RT.rgba(255,0,0,255));
    texturepixelsdgnode.bindings.append(scene.constructOperator({
      operatorName: 'setFramePixels',
      entryFunctionName: 'setFramePixels',
      srcFile: 'KL/AnimationReview.kl',
      parameterLayout: [
        'uniforms.drawFrame',
        'uniforms.frameColor',
        'uniforms.width',
        'uniforms.height',
        'self.pixels<>'
      ]
    }));
    
    // create a flat texture material
    var materialNode = scene.constructNode('FlatBlendTextureMaterial', {
      textureNode: textureNode.pub,
      disableOptions: [FABRIC.SceneGraph.OpenGLConstants.GL_DEPTH_TEST],
      enableOptions: [FABRIC.SceneGraph.OpenGLConstants.GL_BLEND],
      blendModeSfactor: FABRIC.SceneGraph.OpenGLConstants.GL_SRC_ALPHA,
      blendModeDfactor: FABRIC.SceneGraph.OpenGLConstants.GL_ONE_MINUS_SRC_ALPHA,
    });
    
    // now create a plane
    var instanceNode = scene.constructNode('Instance', {
      transformNode: transformNode.pub,
      geometryNode: planeNode.pub,
    });

    // now create the time relevant members
    var dgnode = instanceNode.getDGNode();
    dgnode.addMember('colorBlend','Scalar',1.0);
    dgnode.addMember('planeTime','Scalar',options.planeTime);
    dgnode.addMember('planeBlend','Scalar',options.planeBlend);
    instanceNode.addMemberInterface(dgnode, 'planeTime', true);
    instanceNode.addMemberInterface(dgnode, 'planeBlend', true);
    instanceNode.addMemberInterface(textureuniformsdgnode, 'drawFrame', true);
    instanceNode.addMemberInterface(textureuniformsdgnode, 'frameColor', true);
    instanceNode.addMemberInterface(textureuniformsdgnode, 'paint', true);
    instanceNode.addMemberInterface(textureuniformsdgnode, 'paintColor', true);
    instanceNode.addMemberInterface(textureuniformsdgnode, 'paintErase', true);
    instanceNode.addMemberInterface(textureuniformsdgnode, 'paintRadius', true);
    instanceNode.addMemberInterface(textureuniformsdgnode, 'UVs', true);
    instanceNode.addMemberInterface(dgnode, 'planeBlend', true);
    
    // link the material node to the animation controller
    var animationdgnode = animationControllerNode.getDGNode();
    dgnode.setDependency(animationdgnode,'animation');
    dgnode.bindings.append(scene.constructOperator({
      operatorName: 'setTextureBlend',
      srcFile: 'KL/AnimationReview.kl',
      entryFunctionName: 'setTextureBlend',
      parameterLayout: [
        'self.colorBlend',
        'self.drawToggle',
        'self.planeTime',
        'self.planeBlend',
        'animation.localTime'
      ]
    }));
    
    // create an operator to load the uniform to the GPU    
    instanceNode.getRedrawEventHandler().preDescendBindings.append(scene.constructOperator({
      operatorName: 'loadColorBlend',
      srcFile: 'FABRIC_ROOT/SceneGraph/KL/loadUniforms.kl',
      preProcessorDefinitions: {
        ATTRIBUTE_NAME: 'u_colorBlend',
        ATTRIBUTE_ID: FABRIC.SceneGraph.getShaderParamID('colorBlend'),
        DATA_TYPE: 'Scalar'
      },
      entryFunctionName: 'loadUniform',
      parameterLayout: [
        'shader.shaderProgram',
        'instance.colorBlend'
      ]
    }));
    
    // set the material
    instanceNode.pub.addMaterialNode(materialNode.pub);
    
    if(!uvPlaneGeometry){
      uvPlaneGeometry = scene.constructNode('Plane', {
        length: 1.0,
        width: 1.0,
        lengthSections: 1,
        widthSections: 1,
      });
    }
    var inst = scene.constructNode('Instance', {
      transformNode: transformNode.pub,
      geometryNode: uvPlaneGeometry.pub,
    });
    
    // setup manipulation
    var painting = false;
    var height = 0;
    var paint = function(evt) {
      if(!painting) {
        return;
      }
      var mousePos = viewportNode.getElementCoords(evt);
      mousePos.y = height - 1 - mousePos.y;
      uvViewportNode.pub.setQueryPos(mousePos);
      viewportNode.pub.redraw();
    };
    var beginpaint = function(evt) {
      instanceNode.pub.setPaint(1);
      uvViewportNode.pub.setQueryToggle(true);
      painting = true;
      instanceNode.pub.setPaintErase(evt.button == 2);
      paint(evt);
    };
    var endpaint = function(evt) {
      painting = false;
      instanceNode.pub.setPaint(0);
      uvViewportNode.pub.setQueryToggle(false);
      viewportNode.pub.redraw();
    };

    var enabledManip = false;
    instanceNode.pub.enableManipulation = function() {
      if(enabledManip)
        return;
      height = viewportNode.getFabricWindowObject().windowNode.getData('height',0);
      // setup the flat material for drawing
    //  instanceNode.pub.addMaterialNode( uvViewportNode.pub.getFlatUVMaterial() );
      inst.pub.addMaterialNode( uvViewportNode.pub.getFlatUVMaterial() );
      
      uvViewportNode.pub.redraw();

      // setup all of the event listeners
      viewportNode.getWindowElement().addEventListener('mousedown', beginpaint, false);
      viewportNode.getWindowElement().addEventListener('mouseup', endpaint, false);
      viewportNode.getWindowElement().addEventListener('mousemove', paint, false);

      enabledManip = true;
    };
    instanceNode.pub.disableManipulation = function() {
      if(!enabledManip)
        return;

      // remove the flat uv material for drawing
    //  instanceNode.pub.removeMaterialNode( uvViewportNode.pub.getFlatUVMaterial() );
      inst.pub.removeMaterialNode( uvViewportNode.pub.getFlatUVMaterial() );
      

      viewportNode.getWindowElement().removeEventListener('mousemove', paint);
      viewportNode.getWindowElement().removeEventListener('mouseup', endpaint);
      viewportNode.getWindowElement().removeEventListener('mousedown', beginpaint);
      enabledManip = false;
    };
    
    // create an encode event handler and connect it up
    var eventHandler = instanceNode.constructEventHandlerNode('Encode');
    encodeEventNode.getEventHandler().appendChildEventHandler(eventHandler);
    eventHandler.setScope('uniforms',textureuniformsdgnode);
    eventHandler.setScope('texture',texturepixelsdgnode);
    eventHandler.addMember('resource', 'FabricResource');

    eventHandler.preDescendBindings.append(scene.constructOperator({
      operatorName: 'encodeImage',
      srcFile: 'FABRIC_ROOT/SceneGraph/KL/encodeImage.kl',
      entryFunctionName: 'encodeImageLDR',
      parameterLayout: [
            'uniforms.width',
            'uniforms.height',
            'texture.pixels',
            'self.resource'
          ]
    }));
    
    instanceNode.pub.savePNG = function(path,fileName) {
      path.fileName = fileName;
      eventHandler.putResourceToFile('resource',path);
    };
    
    instanceNode.pub.loadPNG = function(path,fileName) {
      path.fileName = fileName;
    }

    return instanceNode;    
  }});    

$(document).ready(function() {
  
  $('#loadingDialog').dialog({
    modal: true
  });

  var scene = FABRIC.SceneGraph.createScene();
  var viewport = scene.constructNode('Viewport', {
    windowElement: document.getElementById('FabricContainer'),
    backgroundColor: new FABRIC.RT.Color(0.0, 0.0, 0.0, 0.0),
  });

  // Create a camera to draw the scene from
  var camera = scene.constructNode('TargetCamera', {
    position: new FABRIC.RT.Vec3(20, 20, 20),
    target: new FABRIC.RT.Vec3(0, 0, 0),
    nearDistance: 0.01,
    farDistance: 1000
  });
  viewport.setCameraNode(camera);
  
viewport.setBackgroundTextureNode(scene.constructNode('Image2D', {
    url: '../../BasicDemos/Resources/fabric-demo-gradient.png'
  }));
  
  // create an offscreen viewport to draw the UVs to
  var uvViewport = scene.constructNode('UVViewport', {
    mainViewportNode: viewport
  });
  
  // create a node to control the encode events
  var encodeEvent = scene.constructNode('pngEncodeEventNode');

  var light = scene.constructNode('PointLight', { position: new FABRIC.RT.Vec3(10000, 10000, 10000) });

  var cameraManipulator = scene.constructNode("CameraManipulator", { targetNode:camera } );

  scene.constructNode('Instance', {
          geometryNode: scene.constructNode('Grid', {
              size_x: 120.0,
              size_z: 120.0,
              sections_x: 32,
              sections_z: 32 }),
          materialNode: scene.constructNode('FlatMaterial')
      });
  
  // create a material and primitive to draw the other cameras  
  var cameraMaterial = scene.constructNode('FlatMaterial', { color: FABRIC.RT.rgb(0.0, 0.0, 1.0, 1) });
  var cameraPrimitive = scene.constructNode('CameraPrimitive', { size: 1.2 });
  
  // create a material for all alembic content
  var materialNode = scene.constructNode('PhongTextureSimpleMaterial', {
      diffuseTextureNode: scene.constructNode('Image2D', { url: '../../Alembic/Models/frog_diffuse.png' }),
      lightNode: scene.constructNode('PointLight', {
        position: new FABRIC.RT.Vec3(100, 100, 0)
      }),
      specularColor: FABRIC.RT.rgba(0.2,0.2,0.2,1)
    });

  // hook for the alembic content
  var resourceLoadNode = undefined;
  var parsedCameras = {};
  var parsedInstances = {};

  // deal with camera switching
  var usedCamera = "userCamera";
  var switchCamera = function(cameraName) {
    if(cameraName == usedCamera)
      return;
    usedCamera = cameraName;
    
    if(cameraName == "userCamera") {
      viewport.setCameraNode(camera);
      uvViewport.setCameraNode(camera);
      for(var name in parsedCameras) {
        parsedCameras[name].setDrawToggle(true);
      }
    } else {
      viewport.setCameraNode(resourceLoadNode.getParsedNodes()[cameraName]);
      uvViewport.setCameraNode(resourceLoadNode.getParsedNodes()[cameraName]);
      for(var name in parsedCameras) {
        parsedCameras[name].setDrawToggle(false);
      }
    }
    viewport.redraw();
  };
  
  // load the alembic content based on user interaction
  var timeRange = undefined;
  var loadAlembicAsset = function(url) {
    var assets = scene.importAssetFile(url, {
      dependentNode: viewport
    });
    assets['frog'].addOnLoadSuccessCallback(function(){
      // get the first asset name
      var assetName = undefined;
      for(var name in assets) {
        assetName = name;
        break;
      }
        
      resourceLoadNode = assets[assetName];
      var parsedNodes = resourceLoadNode.getParsedNodes();

      // setup html for the object and camera list        
      var cameraListHtml = "<option value='userCamera'>Free Camera</option>";
        
      // setup the animation time
      timeRange = resourceLoadNode.getAnimationController().getTimeRange();
      $('#localtime').slider({
          min: timeRange.x,
          max: timeRange.y,
          step: 0.01
      });
        
      // loop over all assets and create an instance
      for(var name in parsedNodes) {
        var parsedNode = parsedNodes[name];
        if(parsedNode.isTypeOf('Triangles')) {
          parsedInstances[name] = scene.constructNode('Instance', {
            transformNode: resourceLoadNode.getCorrespondingTransform(name),
            geometryNode: parsedNode,
            materialNode: materialNode
          });
        }
        else if(parsedNode.isTypeOf('Camera')) {
            
          // create a primitive for this camera
          parsedCameras[name] = scene.constructNode('Instance', {
            transformNode: parsedNode.getTransformNode(),
            geometryNode: cameraPrimitive,
            materialNode: cameraMaterial
          });

          // add the camera as an option to the list
          cameraListHtml += "<option value='"+name+"'>"+name.substring(name.lastIndexOf('/')+1,1000)+"</option>"
            
        }
      }
        
      // attach an on-select event to the camera list 
      $('#cameralist').html(cameraListHtml).change( function(ui) {
        switchCamera($('#cameralist').attr('value'));
      });
        
      // now let's switch the camera
      for(var name in parsedCameras) {
        switchCamera(name);
        break;
      }

      //$('#loadingDialog').dialog('close');
      viewport.redraw();
    });
  };
  
  // for now let's load the frog
  loadAlembicAsset('../../Alembic/Models/frog.abc');
  
  // create a map for all of the planes
  var planes = {};

  // create a single geometry that will be used for all planes
  var planeGeometry = scene.constructNode('Plane', {
    length: 1.0,
    width: 1.0,
    lengthSections: 1,
    widthSections: 1,
  });

  // keep a key for the plane that's currently in use
  var currentPlane = undefined;
  var currentKey = undefined;

  // paint a new plane
  var brushRadius = 1.5;
  var brushColor = FABRIC.RT.rgba(255,0,0,130);

    
  // setup the function to change the active plane    
  var switchPlane = function(key) {
    var plane = planes[key];
    if(plane == undefined)
      return;
    currentPlane = plane;
    currentKey = key;
    
    plane.instance.setPaintColor(brushColor);
    plane.instance.setPaintRadius(brushRadius);
    
    scene.animation.setTime(plane.time, false);
    $('#localtime').slider('value', plane.time);
    $('#planeblend').slider('value', plane.instance.getPlaneBlend());
    $('#planeblend').unbind('slide').bind('slide',
        function(event, ui) {
          plane.instance.setPlaneBlend(ui.value);
          viewport.redraw();
      });
    
    // set the frame enable or disabled
    for(var oldKey in planes) {
      planes[oldKey].instance.setDrawFrame(oldKey == key);
    }
    
    plane.instance.setPaintColor(brushColor);
    plane.instance.setPaintRadius(brushRadius);
    
    switchCamera(plane.camera);
    $("#cameralist option[value='"+plane.camera+"']").attr('selected',true);
  };

  var paintPlane = function(options) {
    if(!options)
      options = {};
    
    // only allow to paint from animated cameras
    if(usedCamera == 'userCamera'){
      return;
    }

    // create a key to identify the plane
    var timeKey = resourceLoadNode.getAnimationController().getLocalTime();
    timeKey = ''+parseInt(timeKey * 30 + 0.5);
    if(currentKey == timeKey)
      return;
    
    // check if we need to create a new plane
    if(planes[timeKey] == undefined ) {
      var newPlane = scene.constructNode('PaintPlaneInstance', {
        viewportNode: viewport,
        uvViewportNode: uvViewport,
        planeNode: planeGeometry,
        animationControllerNode: resourceLoadNode.getAnimationController(),
        planeTime: resourceLoadNode.getAnimationController().getLocalTime(),
        planeBlend: options.blend ? options.blend : 5.0 / 30.0,
        resolutionFactor: 0.2,
        paintColor: brushColor,
        paintRadius: brushRadius,
        encodeEventNode: encodeEvent,
        path: options.path,
        transform: options.transform
      });
      planes[timeKey] = {
        camera: usedCamera,
        instance: newPlane,
        time: resourceLoadNode.getAnimationController().getLocalTime()
      };
  
      // re-create the list html
      var planeListHtml = "";
      for(var key in planes) {
        if(key == timeKey)
          planeListHtml += "<option selected value='"+key+"'>At time "+planes[key].time+"</option>";
        else
          planeListHtml += "<option value='"+key+"'>At time "+planes[key].time+"</option>";
      }
      $('#planelist').html(planeListHtml).change( function (ui) {
        switchPlane($('#planelist').attr('value'));
        viewport.redraw();
      });
      
      // disable loading
      $('#saveload').button({text: true, label: 'Save'});
    }
    switchPlane(timeKey);
  };
  
  // setup hotkeys
  var painting = false;
  window.onkeydown = function(evt) {
    if(!timeRange)
      return;
    
    var time = scene.animation.getTime() % timeRange.y;
    if(evt.keyCode == 37 && time > timeRange.x) { // left arrow
      time -= 1.0 / 30.0;
      scene.animation.pause();
      scene.animation.setTime(time);
      $('#localtime').slider('value', time);
      scene.redrawAllViewports();
    } else if(evt.keyCode == 39 && time < timeRange.y) { // right arrow
      time += 1.0 / 30.0;
      scene.animation.pause();
      scene.animation.setTime(time);
      $('#localtime').slider('value', time);
      scene.redrawAllViewports();
    } else if(evt.keyCode == 38) { // up arrow
      $('#play').button('option', {
        label: 'Pause',
        icons: {
          primary: 'ui-icon-pause'
        }
      });
      var localTime = $('#localtime').slider();
      scene.animation.play( function() {
        localTime.slider('value', resourceLoadNode.getAnimationController().getLocalTime());
      });
    } else if(evt.keyCode == 40) { // down arrow
      $('#play').button('option', {
        label: 'Play',
        icons: {
          primary: 'ui-icon-play'
        }
      });
      scene.animation.pause();
    }
    else if(evt.shiftKey || evt.keyCode == 16) {
      cameraManipulator.disable();
      paintPlane();
      
      var count = FABRIC.getActiveAsyncTaskCount();
      if(count>0){
        FABRIC.appendOnResolveAsyncTaskCallback(function(label, countRemaining){
          if(countRemaining===0){
            if(currentPlane){
              currentPlane.instance.enableManipulation();
            }
            viewport.redraw();
            return true;
          }
        });
      }
      else{
        if(currentPlane){
          currentPlane.instance.enableManipulation();
        }
        viewport.redraw();
      }
      painting = true;
    }
  };
  
  window.onkeyup = function(evt) {
    if(painting) { 
      var count = FABRIC.getActiveAsyncTaskCount();
      if(count>0){
        FABRIC.appendOnResolveAsyncTaskCallback(function(label, countRemaining){
          if(countRemaining===0){
            if(currentPlane)
              currentPlane.instance.disableManipulation();
            cameraManipulator.enable();
            return true;
          }
        });
      }
      else{
        if(currentPlane)
          currentPlane.instance.disableManipulation();
        cameraManipulator.enable();
      }
    }
  }; 
  
  // create a slider for the light direction
  $('#lightDirection').slider({
      min: 0.0,
      max: 360.0,
      step: 0.5
    }).bind('slide',
      function(event, ui) {
        var pos = new FABRIC.RT.Vec3(10000,10000,10000);
        var rot = new FABRIC.RT.Quat().setFromAxisAndAngle(new FABRIC.RT.Vec3(0,1,0), Math.degToRad(ui.value));
        pos = rot.rotateVector(pos);
        light.setPosition(pos);
        scene.redrawAllViewports();
    });  

  $('#localtime').slider().bind('slide',
      function(event, ui) {
        $('#play').button('option', {
          label: 'Play',
          icons: {
            primary: 'ui-icon-play'
          }
        });
        scene.animation.pause();
        scene.animation.setTime(ui.value);
        scene.redrawAllViewports();
    });  
  $('#planeblend').slider({
      min: 0.0,
      max: 2.0,
      step: 1.0/30.0,
      value: 5.0/30.0
    });
  
  $('#saveload').button({
      text: true
    })
    .click(function() {
      if(!resourceLoadNode)
        return;
      
      if($(this).text() == 'Save') {
        // ensure that we have some planes
        var planeCount = 0;
        for(var name in planes)
          planeCount++;
        if(planeCount == 0) {
          throw("We cannot save a scene with no planes in it!");
        }
        
        // fire the png encode event!
        encodeEvent.fire();
        
        var jsonData = {};
        
        // store general scene data
        jsonData.currentTime = scene.animation.getTime();
        jsonData.currentCamera = usedCamera;
        jsonData.currentPlane = currentKey;
        jsonData.currentRadius = brushRadius;
        jsonData.currentColor = brushColor;

        // get a path handle
        var path = scene.IO.queryUserFileAndFolderHandle(scene.IO.forOpenWithWriteAccess, "Animation Review Data", "json", "review");
        var jsonFileName = path.fileName;
        var basename = path.fileName.split('.')[0];
        
        // store all planes
        jsonData.planes = {};
        for(var name in planes) {
          planes[name].instance.savePNG(path,basename+'.'+name+'.png');
          jsonData.planes[name] = {};
          jsonData.planes[name].camera = planes[name].camera;
          jsonData.planes[name].filename = basename+'.'+name+'.png';
          jsonData.planes[name].transform = planes[name].instance.getTransformNode().getLocalXfo();
          jsonData.planes[name].time = planes[name].time;
          jsonData.planes[name].blend = planes[name].instance.getPlaneBlend();
        }
        
        // save the json file
        path.fileName = jsonFileName;
        scene.IO.putTextFile(JSON.stringify(jsonData), path);
        
      } else {
        
        // get a path handle
        var path = scene.IO.queryUserFileAndFolderHandle(scene.IO.forOpen, "Animation Review Data", "json", "review");
        var jsonData = JSON.parse(scene.IO.getTextFile(path));
        
        // first create all planes
        for(var key in jsonData.planes) {
          switchCamera(jsonData.planes[key].camera);
          scene.animation.setTime(parseFloat(jsonData.planes[key].time));
          resourceLoadNode.getAnimationController().setLocalTime(jsonData.planes[key].time);
          path.fileName = jsonData.planes[key].filename;
          $('#planeblend').slider("option", "value", jsonData.planes[key].blend);
          paintPlane({path: path, transform: jsonData.planes[key].transform, key: key, blend: jsonData.planes[key].blend});
        }
        
        brushColor = jsonData.currentColor;
        brushRadius = jsonData.currentRadius;

        $('#brushOpacity').slider("option", "value", brushColor.a);
        $('#brushRadius').slider("option", "value", brushRadius);
        $('#brushColor').ColorPicker("option", "color", brushColor);
        
        switchPlane(parseInt(jsonData.currentKey));
        switchCamera(jsonData.currentCamera);

        scene.animation.setTime(parseFloat(jsonData.currentTime));
        resourceLoadNode.getAnimationController().setLocalTime(jsonData.currentTime);
        $('#localtime').slider('value', parseFloat(jsonData.currentTime));

        viewport.redraw();
      }
    });

  $('#play').button({
      text: true,
      icons: {
        primary: 'ui-icon-play'
      }
    })
    .click(function() {
      if ($(this).text() == 'Play') {
        $(this).button('option', {
          label: 'Pause',
          icons: {
            primary: 'ui-icon-pause'
          }
        });
        scene.animation.play();
      } else {
        $(this).button('option', {
          label: 'Play',
          icons: {
            primary: 'ui-icon-play'
          }
        });
        scene.animation.pause();
      }
    });
  scene.addEventListener('timechanged', function(evt){
    if(evt.playing){
      $('#localtime').slider().slider('value', scene.animation.getTime());
    }
  });

  $('#brushColor').ColorPicker({
      flat: true,
      color: { r: 255, g: 0, b: 0} ,
      onChange: function(hsb, hex, rgb) {
        brushColor.r = rgb.r;
        brushColor.g = rgb.g;
        brushColor.b = rgb.b;
        currentPlane.instance.setPaintColor(brushColor);
        scene.redrawAllViewports();
      }
    });
  $('#brushOpacity').slider({
      min: 1.0,
      max: 60.0,
      step: 1.0,
      value: brushColor.a
    }).bind('slide',
      function(event, ui) {
        brushColor.a = ui.value;
        currentPlane.instance.setPaintColor(brushColor);
        scene.redrawAllViewports();
    });  
  $('#brushRadius').slider({
      min: 0.5,
      max: 5.0,
      step: 0.01,
      value: brushRadius
    }).bind('slide',
      function(event, ui) {
        brushRadius = ui.value;
        currentPlane.instance.setPaintRadius(brushRadius);
        scene.redrawAllViewports();
    });  
  $('#planeblend').slider({
    });

  FABRIC.appendOnResolveAsyncTaskCallback(function(label, nbRemaining, doneWeight, totalWeight) {
    $('#loadingProgressBar').progressbar({
      value: (1.0-(doneWeight/totalWeight))*100
    });
    if (nbRemaining===0) {
      $('#loadingDialog').dialog('close');
      var errors = scene.getErrors();
      if (errors.length > 0) {
        throw (errors.toString());
      }
      
      viewport.redraw();
      return true;
    }
  });
  
});

// jQuert UI Styling classes
$(document).ready(function() {
  $(".box").addClass("ui-widget");
  $(".box h2").addClass("ui-widget-header ui-corner-all");
  $(".content").addClass("ui-widget-content");
});

</script>

  </head> 
  <body>
    <div id="loadingDialog" title="Loading...">
      <h4 id="loadingDesc">Downloading Alembic File.<br>This may take some time.</h4>
      <div id="loadingProgressBar" class="ui-progressbar-value"></div>
    </div>
    <div id="instructionsDialog" title="Instructions">
      Hold down 'shift' to paint.
    </div>
    <div id="wrapper">
      <div id="editor">
        <div id="viewer">
          <div id="FabricContainer"></div> 
        </div><!--viewer-->
        <div id="sidebar">
          <div class="box">
            <h2>Scene</h2>
            <div class="content">
                <label for="lightDirection" >Light Direction:</label>
                <div id='lightDirection' style="margin-top:10px;"></div>
                <select multi size=3 id='cameralist' style='width: 200px; margin-top: 10px'>
                  <option value='userCamera'>Free Camera</option>
                </select>
                <button id="saveload">Open</button>
            </div><!--content-->
            <h2>Planes</h2>
            <div class="content">
                <p>Hold down 'shift' to paint</p>
                <select multi size=5 id='planelist' style='width: 200px'>
                </select>
                <div id='planeblend' style="margin-top:10px;"></div>
                <p id="brushColor"></p>
                
                <label for="brushOpacity" >Brush Opacity:</label>
                <div id='brushOpacity' style="margin-top:10px;"></div>
                
                <label for="brushRadius" >Brush Radius:</label>
                <div id='brushRadius' style="margin-top:10px;"></div>
            </div><!--content-->
          </div><!--box-->
        </div><!--sidebar-->
        
        <div id="timeControls">
          <div class="box">
            <h2>Playback</h2>
            <div class="content">
                <button id="play">Play</button>
                <div id='localtime'></div>
            </div><!--content-->
          </div><!--box-->
        </div><!--timeControls-->
        
      </div> <!--editor-->
    </div><!--wrapper-->
  </body> 
  </html>
