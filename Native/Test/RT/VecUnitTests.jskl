//IMPORTANT - READ THIS FIRST:
//
//  This code runs in both KL and JS. To declare any local variable, add new entries
//  to runTests's input arg 'localVariables'.
//
//  Don't use any operators like '*', '-' etc. Instead, use the JS naming, and make 
//  sure the KL equivalent version have been generated by calling 'appendKLOpAdaptors'.
//
//  To test KL unary operator such as '+=', use 'addInPlace' nomenclature instead, and 
//  make sure that KL adaptors have been generated by calling 'appendKLOpAdaptors' and 
//  JS adaptors have been  generated by calling 'defineInPlaceOpAdaptors'.

v1.appendResult(tests, results, 'set');

v3.set(v1);
v3.setNull();
v3.appendResult(tests, results, 'setNull');

v3 = v1.multiplyScalar(1.000005);
v1.appendBooleanResult(tests, results, 'equal', v1.equal(v1));
v1.appendBooleanResult(tests, results, 'equal2', v1.equal(v3));
v1.appendBooleanResult(tests, results, 'equal3', v1.almostEqual(v3, 1e-4));

v3 = v1.add(v2);
v3.appendResult(tests, results, 'add');

v3.addInPlace(v2);
v3.appendResult(tests, results, 'addInPlace');

v3 = v1.subtract(v2);
v3.appendResult(tests, results, 'subtract');

v3.subtractInPlace(v2);
v3.appendResult(tests, results, 'subtractInPlace');

v3 = v1.multiply(v2);
v3.appendResult(tests, results, 'multiply');

v3.multiplyInPlace(v2);
v3.appendResult(tests, results, 'multiplyInPlace');

v3 = v1.multiplyScalar(2.0);
v3.appendResult(tests, results, 'multiplyScalar');

v3.set(v1);
v3.multiplyScalarInPlace(3.0);
v3.appendResult(tests, results, 'multiplyScalarInPlace');

v3 = v1.divide(v2);
v3.appendResult(tests, results, 'divide');

v3.divideInPlace(v2);
v3.appendResult(tests, results, 'divideInPlace');

v3 = v1.divideScalar(2.0);
v3.appendResult(tests, results, 'divideScalar');

v3.set(v1);
v3.divideScalarInPlace(3.0);
v3.appendResult(tests, results, 'dividecalarInPlace');

v3 = v1.negate();
v3.appendResult(tests, results, 'negate');

v3 = v1.invert();
v3.appendResult(tests, results, 'invert');

v3.setNull();
v3.invert();//log 'bad divisor'

s1 = v1.dot(v2);
v1.appendScalarResult(tests, results, 'dot', s1);

s1 = v1.lengthSquared();
v1.appendScalarResult(tests, results, 'lengthSquared', s1);

s1 = v1.length();
v1.appendScalarResult(tests, results, 'length', s1);

v3 = v1.unit();
v3.appendResult(tests, results, 'unit');

v3.set(v2);
v3.setUnit(); //todo: check return result when KL compile issue is fixed
v3.appendResult(tests, results, 'setUnit');

v3 = v1.multiplyScalar(2.0);
v3 = v3.clamp(v1.negate(),v1);
v3.appendResult(tests, results, 'clampDown');

v3 = v1.multiplyScalar(-2.0);
v3 = v3.clamp(v1.negate(),v1);
v3.appendResult(tests, results, 'clampUp');

s1 = v1.angleTo( v2 );
v1.appendScalarResult(tests, results, 'angleTo', s1);

s1 = v1.distanceTo( v2 );
v1.appendScalarResult(tests, results, 'distanceTo', s1);

v3 = v1.linearInterpolate( v2, 0.25 );
v3.appendResult(tests, results, 'linearInterpolate');
