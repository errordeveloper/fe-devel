//IMPORTANT - READ THIS FIRST:
//
//  This code runs in both KL and JS. To declare any local variable, add new entries
//  to runTests's input arg 'localVariables'.
//
//  Don't use any operators like '*', '-' etc. Instead, use the JS naming, and make 
//  sure the KL equivalent version have been generated by calling 'appendKLOpAdaptors'.
//
//  To test KL unary operator such as '+=', use 'addInPlace' nomenclature instead, and 
//  make sure that KL adaptors have been generated by calling 'appendKLOpAdaptors' and 
//  JS adaptors have been  generated by calling 'defineInPlaceOpAdaptors'.

q1.set(1.0,2.0,3.0,4.0);
q1.appendResult(tests, results, 'set');

v1.set(0.0,1.0,0.0);
q1.setFromAxisAndAngle(v1, -1.570796326794896);
q1.appendResult(tests, results, 'setFromAxisAndAngle');

v1.set(1.0, 0.0, 0.0);
q1.rotateVector(v1).appendResult(tests, results, 'rotateVector3');

v1.set(1.0, 0.0, 0.0);
v2.set(0.0, 1.0, 0.0);

ro1.setYZX();
e1.set(0.0, 1.570796326794896, 1.570796326794896, ro1);
q1.setFromEuler(e1);
q1.appendResult(tests, results, 'setFromEuler');
q1.rotateVector(v1).appendResult(tests, results, 'setFromEuler_rotateVector');
q1.rotateVector(v2).appendResult(tests, results, 'setFromEuler_rotateVector2');
m1 = e1.toMat33();
m1.multiplyVector(v1).appendResult(tests, results, 'eulerMat_rotateVector');
m1.multiplyVector(v2).appendResult(tests, results, 'eulerMat_rotateVector2');
q1.setFromMat33(m1);
q1.appendResult(tests, results, 'setFromMat33');
q1.rotateVector(v1).appendResult(tests, results, 'setFromMat33_rotateVector');
q1.rotateVector(v2).appendResult(tests, results, 'setFromMat33_rotateVector2');
m1 = q1.toMat33();
m1.multiplyVector(v1).appendResult(tests, results, 'toMat33_rotateVector');
m1.multiplyVector(v2).appendResult(tests, results, 'toMat33_rotateVector2');

v1.set(1.0, 0.0, 0.0);
v2.set(1.0, -1.0, 2.0);
v2.setUnit();
v2.appendResult(tests, results, 'targetVector');
q1.setFrom2Vectors(v1, v2, true);
q1.appendResult(tests, results, 'setFrom2Vectors');
q1.rotateVector(v1).appendResult(tests, results, 'setFrom2Vectors_rotateVector');

v1.set(1.0, 0.0, 0.0);
v2.set(-1.0, 0.0, 0.0);
q1.setFrom2Vectors(v1, v2, false);
q1.setFrom2Vectors(v1, v2, true);
q1.rotateVector(v1).appendResult(tests, results, 'setFrom2Vectors_rotateVector2');


q1.set(1.0,2.0,3.0,4.0);
q2.set(1.0,-1.0,1.0,-2.0);

res = q1.multiplyScalar(1.000005);
q1.appendBooleanResult(tests, results, 'equal', q1.equal(q1));
q1.appendBooleanResult(tests, results, 'equal2', q1.equal(res));
q1.appendBooleanResult(tests, results, 'equal3', q1.almostEqual(res, 1e-4));

res = q1.add(q2);
res.appendResult(tests, results, 'add');

res.addInPlace(q2);
res.appendResult(tests, results, 'addInPlace');

res = q1.subtract(q2);
res.appendResult(tests, results, 'subtract');

res.subtractInPlace(q2);
res.appendResult(tests, results, 'subtractInPlace');

res = q1.multiply(q2);
res.appendResult(tests, results, 'multiply');

res.multiplyInPlace(q2);
res.appendResult(tests, results, 'multiplyInPlace');

res = q1.multiplyScalar(2.0);
res.appendResult(tests, results, 'multiplyScalar');

res.set(q1);
res.multiplyScalarInPlace(3.0);
res.appendResult(tests, results, 'multiplyScalarInPlace');

res = q1.divide(q2);
res.appendResult(tests, results, 'divide');

res.divideInPlace(q2);
res.appendResult(tests, results, 'divideInPlace');

res = q1.divideScalar(2.0);
res.appendResult(tests, results, 'divideScalar');

q1.set(1.0,2.0,3.0,0.5);
q2.set(-3.0,2.0,-1.0,-1.5);

q1.appendScalarResult(tests, results, 'length', q1.length());
q1.appendScalarResult(tests, results, 'lengthSquared', q1.lengthSquared());

q1.unit().appendResult(tests, results, 'unit');
q1.setUnit();
q2.setUnit();
q2.appendResult(tests, results, 'setUnit');

q1.appendScalarResult(tests, results, 'dot', q1.dot(q2));
q1.conjugate().appendResult(tests, results, 'conjugate');
q1.inverse().appendResult(tests, results, 'inverse');
q1.getXaxis().appendResult(tests, results, 'getXaxis');
q1.getYaxis().appendResult(tests, results, 'getYaxis');
q1.getZaxis().appendResult(tests, results, 'getZaxis');
q1.alignWith(q2);
q1.appendResult(tests, results, 'alignWith');
q1.mirror(1);
q1.appendResult(tests, results, 'mirrorY');

v1.set(0.0,1.0,0.0);
q1.setFromAxisAndAngle(v1, -1.570796326794896);
v1.set(0.0,0.0,-1.0);
q2.setFromAxisAndAngle(v1, 1.570796326794896);

v1.set(1.0,0.0,0.0);
q1.rotateVector(v1).appendResult(tests, results, 'slerp 0');
q1.sphericalLinearInterpolate(q2, 0.25).rotateVector(v1).appendResult(tests, results, 'slerp 0.25');
q1.sphericalLinearInterpolate(q2, 0.5).rotateVector(v1).appendResult(tests, results, 'slerp 0.5');
q1.sphericalLinearInterpolate(q2, 0.75).rotateVector(v1).appendResult(tests, results, 'slerp 0.75');
q2.rotateVector(v1).appendResult(tests, results, 'slerp 1');

q1.rotateVector(v1).appendResult(tests, results, 'lerp 0');
q1.linearInterpolate(q2, 0.25).rotateVector(v1).appendResult(tests, results, 'lerp 0.25');
q1.linearInterpolate(q2, 0.5).rotateVector(v1).appendResult(tests, results, 'lerp 0.5');
q1.linearInterpolate(q2, 0.75).rotateVector(v1).appendResult(tests, results, 'lerp 0.75');
q2.rotateVector(v1).appendResult(tests, results, 'lerp 1');
