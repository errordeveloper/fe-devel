//IMPORTANT - READ THIS FIRST:
//
//  This code runs in both KL and JS. To declare any local variable, add new entries
//  to runTests's input arg 'localVariables'.
//
//  Don't use any operators like '*', '-' etc. Instead, use the JS naming, and make 
//  sure the KL equivalent version have been generated by calling 'appendKLOpAdaptors'.
//
//  To test KL unary operator such as '+=', use 'addInPlace' nomenclature instead, and 
//  make sure that KL adaptors have been generated by calling 'appendKLOpAdaptors' and 
//  JS adaptors have been  generated by calling 'defineInPlaceOpAdaptors'.

q1.set(1.0,2.0,3.0,4.0);
q1.appendResult(tests, results, 'set');

v1.set(0.0,1.0,0.0);
q1.setFromAxisAndAngle(v1, -1.570796326794896);
q1.appendResult(tests, results, 'setFromAxisAndAngle');

v1.set(1.0, 0.0, 0.0);
q1.rotateVector(v1).appendResult(tests, results, 'rotateVector3');

v1.set(1.0, 0.0, 0.0);
v2.set(0.0, 1.0, 0.0);

ro1.setYZX();
e1.set(0.0, 1.570796326794896, 1.570796326794896, ro1);
q1.setFromEuler(e1);
q1.appendResult(tests, results, 'setFromEuler');
q1.rotateVector(v1).appendResult(tests, results, 'setFromEuler_rotateVector');
q1.rotateVector(v2).appendResult(tests, results, 'setFromEuler_rotateVector2');
m1 = e1.toMat33();
m1.multiplyVector(v1).appendResult(tests, results, 'eulerMat_rotateVector');
m1.multiplyVector(v2).appendResult(tests, results, 'eulerMat_rotateVector2');
q1.setFromMat33(m1);
//Don't output this result since the 'trace' is almost 0 and outputs different but equivalent quaternion in KL and JS depending on epsilon
//q1.appendResult(tests, results, 'setFromMat33');
q1.rotateVector(v1).appendResult(tests, results, 'setFromMat33_rotateVector');
q1.rotateVector(v2).appendResult(tests, results, 'setFromMat33_rotateVector2');
m1 = q1.toMat33();
m1.multiplyVector(v1).appendResult(tests, results, 'toMat33_rotateVector');
m1.multiplyVector(v2).appendResult(tests, results, 'toMat33_rotateVector2');

ro1.setXYZ();
e1.set(0.3, 0.5, 0.7, ro1);
q1.setFromEuler(e1);
q1.appendResult(tests, results, 'XYZeuler->quat');
q1.setFromMat33(e1.toMat33());
q1.appendResult(tests, results, 'XYZeuler->mat->quat');

ro1.setXZY();
e1.set(0.3, 0.5, 0.7, ro1);
q1.setFromEuler(e1);
q1.appendResult(tests, results, 'XZYeuler->quat');
q1.setFromMat33(e1.toMat33());
q1.appendResult(tests, results, 'XZYeuler->mat->quat');

ro1.setYXZ();
e1.set(0.3, 0.5, 0.7, ro1);
q1.setFromEuler(e1);
q1.appendResult(tests, results, 'YXZeuler->quat');
q1.setFromMat33(e1.toMat33());
q1.appendResult(tests, results, 'YXZeuler->mat->quat');

ro1.setYZX();
e1.set(0.3, 0.5, 0.7, ro1);
q1.setFromEuler(e1);
q1.appendResult(tests, results, 'YZXeuler->quat');
q1.setFromMat33(e1.toMat33());
q1.appendResult(tests, results, 'YZXeuler->mat->quat');

ro1.setZXY();
e1.set(0.3, 0.5, 0.7, ro1);
q1.setFromEuler(e1);
q1.appendResult(tests, results, 'ZXYeuler->quat');
q1.setFromMat33(e1.toMat33());
q1.appendResult(tests, results, 'ZXYeuler->mat->quat');

ro1.setZYX();
e1.set(0.3, 0.5, 0.7, ro1);
q1.setFromEuler(e1);
q1.appendResult(tests, results, 'ZYXeuler->quat');
q1.setFromMat33(e1.toMat33());
q1.appendResult(tests, results, 'ZYXeuler->mat->quat');

v1.set(1.0, 0.0, 0.0);
v2.set(1.0, -1.0, 2.0);
v2.setUnit();
v2.appendResult(tests, results, 'targetVector');
q1.setFrom2Vectors(v1, v2, true);
q1.appendResult(tests, results, 'setFrom2Vectors');
q1.rotateVector(v1).appendResult(tests, results, 'setFrom2Vectors_rotateVector');

v1.set(1.0, 0.0, 0.0);
v2.set(-1.0, 0.0, 0.0);
q1.setFrom2Vectors(v1, v2, false);
q1.setFrom2Vectors(v1, v2, true);
q1.rotateVector(v1).appendResult(tests, results, 'setFrom2Vectors_rotateVector2');


q1.set(1.0,2.0,3.0,4.0);
q2.set(1.0,-1.0,1.0,-2.0);

res = q1.multiplyScalar(1.000005);
q1.appendBooleanResult(tests, results, 'equal', q1.equal(q1));
q1.appendBooleanResult(tests, results, 'equal2', q1.equal(res));
q1.appendBooleanResult(tests, results, 'equal3', q1.almostEqual(res, 1e-4));

res = q1.add(q2);
res.appendResult(tests, results, 'add');

res.addInPlace(q2);
res.appendResult(tests, results, 'addInPlace');

res = q1.subtract(q2);
res.appendResult(tests, results, 'subtract');

res.subtractInPlace(q2);
res.appendResult(tests, results, 'subtractInPlace');

res = q1.multiply(q2);
res.appendResult(tests, results, 'multiply');

res.multiplyInPlace(q2);
res.appendResult(tests, results, 'multiplyInPlace');

res = q1.multiplyScalar(2.0);
res.appendResult(tests, results, 'multiplyScalar');

res.set(q1);
res.multiplyScalarInPlace(3.0);
res.appendResult(tests, results, 'multiplyScalarInPlace');

res = q1.divide(q2);
res.appendResult(tests, results, 'divide');

res.divideInPlace(q2);
res.appendResult(tests, results, 'divideInPlace');

res = q1.divideScalar(2.0);
res.appendResult(tests, results, 'divideScalar');

q1.set(1.0,2.0,3.0,0.5);
q2.set(-3.0,2.0,-1.0,-1.5);

q1.appendScalarResult(tests, results, 'length', q1.length());
q1.appendScalarResult(tests, results, 'lengthSquared', q1.lengthSquared());

q1.unit().appendResult(tests, results, 'unit');
q1.setUnit();
q2.setUnit();
q2.appendResult(tests, results, 'setUnit');

q1.appendScalarResult(tests, results, 'dot', q1.dot(q2));
q1.conjugate().appendResult(tests, results, 'conjugate');
q1.inverse().appendResult(tests, results, 'inverse');
q1.getXaxis().appendResult(tests, results, 'getXaxis');
q1.getYaxis().appendResult(tests, results, 'getYaxis');
q1.getZaxis().appendResult(tests, results, 'getZaxis');
q1.alignWith(q2);
q1.appendResult(tests, results, 'alignWith');
q1.mirror(1);
q1.appendResult(tests, results, 'mirrorY');

v1.set(0.0,1.0,0.0);
q1.setFromAxisAndAngle(v1, -1.570796326794896);
v1.set(0.0,0.0,-1.0);
q2.setFromAxisAndAngle(v1, 1.570796326794896);

v1.set(1.0,0.0,0.0);
q1.rotateVector(v1).appendResult(tests, results, 'slerp 0');
q1.sphericalLinearInterpolate(q2, 0.25).rotateVector(v1).appendResult(tests, results, 'slerp 0.25');
q1.sphericalLinearInterpolate(q2, 0.5).rotateVector(v1).appendResult(tests, results, 'slerp 0.5');
q1.sphericalLinearInterpolate(q2, 0.75).rotateVector(v1).appendResult(tests, results, 'slerp 0.75');
q2.rotateVector(v1).appendResult(tests, results, 'slerp 1');

q1.rotateVector(v1).appendResult(tests, results, 'lerp 0');
q1.linearInterpolate(q2, 0.25).rotateVector(v1).appendResult(tests, results, 'lerp 0.25');
q1.linearInterpolate(q2, 0.5).rotateVector(v1).appendResult(tests, results, 'lerp 0.5');
q1.linearInterpolate(q2, 0.75).rotateVector(v1).appendResult(tests, results, 'lerp 0.75');
q2.rotateVector(v1).appendResult(tests, results, 'lerp 1');

//to/from Euler deeper testing
v1.set(1.0, 0.0, 0.0);
v2.set(0.6, -0.5, 0.4);
v2.setUnit();
q1.setFrom2Vectors(v1, v2, true);
q1.rotateVector(v1).appendResult(tests, results, 'convertTests_originalQuat');

ro1.setXYZ();
res.setFromEuler(q1.toEuler(ro1));
q1.rotateVector(v1).appendResult(tests, results, 'convertTests_Q->EulerXYZ->Q');
res.setFromMat33(q1.toEuler(ro1).toMat33());
q1.rotateVector(v1).appendResult(tests, results, 'convertTests_Q->EulerXYZ->M33->Q');

ro1.setXZY();
res.setFromEuler(q1.toEuler(ro1));
q1.rotateVector(v1).appendResult(tests, results, 'convertTests_Q->EulerXZY->Q');
res.setFromMat33(q1.toEuler(ro1).toMat33());
q1.rotateVector(v1).appendResult(tests, results, 'convertTests_Q->EulerXZY->M33->Q');

ro1.setYXZ();
res.setFromEuler(q1.toEuler(ro1));
q1.rotateVector(v1).appendResult(tests, results, 'convertTests_Q->EulerYXZ->Q');
res.setFromMat33(q1.toEuler(ro1).toMat33());
q1.rotateVector(v1).appendResult(tests, results, 'convertTests_Q->EulerYXZ->M33->Q');

ro1.setYZX();
res.setFromEuler(q1.toEuler(ro1));
q1.rotateVector(v1).appendResult(tests, results, 'convertTests_Q->EulerYZX->Q');
res.setFromMat33(q1.toEuler(ro1).toMat33());
q1.rotateVector(v1).appendResult(tests, results, 'convertTests_Q->EulerYZX->M33->Q');

ro1.setZXY();
res.setFromEuler(q1.toEuler(ro1));
q1.rotateVector(v1).appendResult(tests, results, 'convertTests_Q->EulerZXY->Q');
res.setFromMat33(q1.toEuler(ro1).toMat33());
q1.rotateVector(v1).appendResult(tests, results, 'convertTests_Q->EulerZXY->M33->Q');

ro1.setZYX();
res.setFromEuler(q1.toEuler(ro1));
q1.rotateVector(v1).appendResult(tests, results, 'convertTests_Q->EulerZYX->Q');
res.setFromMat33(q1.toEuler(ro1).toMat33());
q1.rotateVector(v1).appendResult(tests, results, 'convertTests_Q->EulerZYX->M33->Q');
