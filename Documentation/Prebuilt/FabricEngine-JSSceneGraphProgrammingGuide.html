<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>JavaScript Scene Graph Programming Guide</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="JavaScript Scene Graph Programming Guide"><div class="titlepage"><div><div><h1 class="title"><a name="d5e1"></a>JavaScript Scene Graph Programming Guide</h1></div><div><p class="releaseinfo">Fabric Engine Version 1.2.0-beta</p></div><div><p class="copyright">Copyright Â© 2010-2012 Fabric Engine Inc.</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#d5e8">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e10">Installation</a></span></dt><dt><span class="section"><a href="#d5e15">What's Fabric Engine's SceneGraph?</a></span></dt><dt><span class="section"><a href="#d5e37">Abstraction of the Dependency Graph</a></span></dt><dt><span class="section"><a href="#d5e46">Scene Object and SceneGraphNode Construction</a></span></dt><dt><span class="section"><a href="#d5e58">Public and Private Interfaces</a></span></dt><dt><span class="section"><a href="#d5e65">Custom SceneGraphNodes and Inheritance</a></span></dt><dt><span class="section"><a href="#d5e68">The SceneGraph Debugger</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e75">2. SceneGraph Type System</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e83">Querying types</a></span></dt><dt><span class="section"><a href="#d5e91">JavaScript and KL</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e103">3. Kinematics Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e105">Basic Transform</a></span></dt><dt><span class="section"><a href="#d5e117">Aimed Transform</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e124">4. Animation Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e142">The Animation Controller node</a></span></dt><dt><span class="section"><a href="#d5e146">The TrackAnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e161">The CharacterAnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e172">Binding animation to target nodes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e183">5. Geometry Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e196">Anatomy of a Geometry Node</a></span></dt><dt><span class="section"><a href="#d5e210">Geometry Generation</a></span></dt><dt><span class="section"><a href="#d5e219">Geometry Services</a></span></dt><dt><span class="section"><a href="#d5e224">Geometry Data Copies</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e235">6. Parsers Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e238">The OBJ Parser</a></span></dt><dt><span class="section"><a href="#d5e248">The Collada Parser</a></span></dt><dt><span class="section"><a href="#d5e267">The Alembic Parser</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e292">7. Characters Guide</a></span></dt><dt><span class="chapter"><a href="#d5e295">8. Images and Video Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e298">Anatomy of an Image node</a></span></dt><dt><span class="section"><a href="#d5e307">Loading 2D Images</a></span></dt><dt><span class="section"><a href="#d5e322">Loading 3D Images</a></span></dt><dt><span class="section"><a href="#d5e332">Loading Video</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e343">9. Drawing Pipeline Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e346">Predescend and Postdescend</a></span></dt><dt><span class="section"><a href="#d5e357">Windows</a></span></dt><dt><span class="section"><a href="#d5e368">Setting up the Viewport in OpenGL</a></span></dt><dt><span class="section"><a href="#d5e375">Shaders</a></span></dt><dt><span class="section"><a href="#d5e387">GLSL Uniforms and Attributes</a></span></dt><dt><span class="section"><a href="#d5e392">Materials</a></span></dt><dt><span class="section"><a href="#d5e396">Textures</a></span></dt><dt><span class="section"><a href="#d5e405">Instances</a></span></dt><dt><span class="section"><a href="#d5e427">Shadows</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e435">10. Deferred Rendering Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e445">Setting up the Deferred Renderer</a></span></dt><dt><span class="section"><a href="#d5e454">PrePass Deferred Shaders</a></span></dt><dt><span class="section"><a href="#d5e458">PostPass Deferred Shaders</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e466">11. SceneGraph IO Guide</a></span></dt><dt><span class="chapter"><a href="#d5e469">12. Events Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e472">Setting up a node for event handling</a></span></dt><dt><span class="section"><a href="#d5e490">loadSuccess event</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e497">13. Selection Manager Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e502">Basic Selection Management</a></span></dt><dt><span class="section"><a href="#d5e506">Viewport Selection Manager</a></span></dt><dt><span class="section"><a href="#d5e522">Selection Manipulation Manager</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e530">14. Manipulation Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e542">Setting up a Manipulator</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e554">15. Undo / Redo Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e568">Using Undo and Redo with Manipulation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e572">16. Websockets Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e578">WebSocketManager</a></span></dt><dt><span class="section"><a href="#d5e589">Sending Messages</a></span></dt><dt><span class="section"><a href="#d5e594">Receiving Messages</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e600">17. Bullet Physics Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e606">Creating the Bullet world</a></span></dt><dt><span class="section"><a href="#d5e611">Creating Collision Shapes</a></span></dt><dt><span class="section"><a href="#d5e617">Creating Rigid Bodies</a></span></dt><dt><span class="section"><a href="#d5e627">Creating Soft Bodies</a></span></dt><dt><span class="section"><a href="#d5e632">Creating Constraints</a></span></dt><dt><span class="section"><a href="#d5e644">Creating Anchors</a></span></dt><dt><span class="section"><a href="#d5e648">Array functionality</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e654">18. SceneGraphNode Reference</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e657">SceneGraph.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e659">SceneGraphNode</a></span></dt><dt><span class="section"><a href="#d5e696">ResourceLoad</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e729">Geometry.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e731">Geometry</a></span></dt><dt><span class="section"><a href="#d5e785">GeometryDataCopy</a></span></dt><dt><span class="section"><a href="#d5e808">Points</a></span></dt><dt><span class="section"><a href="#d5e813">Lines</a></span></dt><dt><span class="section"><a href="#d5e818">LineStrip</a></span></dt><dt><span class="section"><a href="#d5e823">Triangles</a></span></dt><dt><span class="section"><a href="#d5e828">Instance</a></span></dt><dt><span class="section"><a href="#d5e887">LayerManager</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e901">Primitives.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e904">LineVector</a></span></dt><dt><span class="section"><a href="#d5e921">Cross</a></span></dt><dt><span class="section"><a href="#d5e944">Axis</a></span></dt><dt><span class="section"><a href="#d5e967">Rectangle</a></span></dt><dt><span class="section"><a href="#d5e996">BoundingBox</a></span></dt><dt><span class="section"><a href="#d5e1025">Grid</a></span></dt><dt><span class="section"><a href="#d5e1054">CameraPrimitive</a></span></dt><dt><span class="section"><a href="#d5e1077">Circle</a></span></dt><dt><span class="section"><a href="#d5e1112">Plane</a></span></dt><dt><span class="section"><a href="#d5e1153">Cuboid</a></span></dt><dt><span class="section"><a href="#d5e1209">Sphere</a></span></dt><dt><span class="section"><a href="#d5e1238">Torus</a></span></dt><dt><span class="section"><a href="#d5e1273">Cone</a></span></dt><dt><span class="section"><a href="#d5e1308">Cylinder</a></span></dt><dt><span class="section"><a href="#d5e1355">Teapot</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1384">Cameras.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1386">Camera</a></span></dt><dt><span class="section"><a href="#d5e1442">FreeCamera</a></span></dt><dt><span class="section"><a href="#d5e1459">TargetCamera</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1464">Images.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1467">Image</a></span></dt><dt><span class="section"><a href="#d5e1472">RenderTargetBufferTexture</a></span></dt><dt><span class="section"><a href="#d5e1486">Image2D</a></span></dt><dt><span class="section"><a href="#d5e1545">Image3D</a></span></dt><dt><span class="section"><a href="#d5e1610">CubeMap</a></span></dt><dt><span class="section"><a href="#d5e1624">Video</a></span></dt><dt><span class="section"><a href="#d5e1650">ScreenGrab</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1664">Materials.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1667">Shaders vs Materials</a></span></dt><dt><span class="section"><a href="#d5e1671">getShaderParamID</a></span></dt><dt><span class="section"><a href="#d5e1674">Shader</a></span></dt><dt><span class="section"><a href="#d5e1679">Material</a></span></dt><dt><span class="section"><a href="#d5e1752">ShadowMapMaterial</a></span></dt><dt><span class="section"><a href="#d5e1757">PointMaterial</a></span></dt><dt><span class="section"><a href="#d5e1783">LineMaterial</a></span></dt><dt><span class="section"><a href="#d5e1809">TransparentMaterial</a></span></dt><dt><span class="section"><a href="#d5e1814">InstancingMaterial</a></span></dt><dt><span class="section"><a href="#d5e1819">PostProcessEffect</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1824">Animation.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1826">AnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e1852">TrackAnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e1893">CharacterAnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e1973">LinearTrackAnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e1978">LinearCharacterAnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e1983">BezierTrackAnimationContainer</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1988">Persistence.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1990">SceneSerializer</a></span></dt><dt><span class="section"><a href="#d5e2022">SceneDeserializer</a></span></dt><dt><span class="section"><a href="#d5e2057">LogWriter</a></span></dt><dt><span class="section"><a href="#d5e2060">LocalStorage</a></span></dt><dt><span class="section"><a href="#d5e2063">FileWriter</a></span></dt><dt><span class="section"><a href="#d5e2066">FileWriterWithBinary</a></span></dt><dt><span class="section"><a href="#d5e2069">FileReader</a></span></dt><dt><span class="section"><a href="#d5e2072">XHRReader</a></span></dt></dl></dd></dl></dd></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>18.1. <a href="#d5e666">SceneGraphNode Options</a></dt><dt>18.2. <a href="#d5e675">SceneGraphNode Methods</a></dt><dt>18.3. <a href="#d5e702">ResourceLoad Options</a></dt><dt>18.4. <a href="#d5e720">ResourceLoad Methods</a></dt><dt>18.5. <a href="#d5e737">Geometry Options</a></dt><dt>18.6. <a href="#d5e752">Geometry Methods</a></dt><dt>18.7. <a href="#d5e790">GeometryDataCopy Options</a></dt><dt>18.8. <a href="#d5e799">GeometryDataCopy Methods</a></dt><dt>18.9. <a href="#d5e833">Instance Options</a></dt><dt>18.10. <a href="#d5e869">GeometryDataCopy Methods</a></dt><dt>18.11. <a href="#d5e892">LayerManager Methods</a></dt><dt>18.12. <a href="#d5e909">LineVector Options</a></dt><dt>18.13. <a href="#d5e926">Cross Options</a></dt><dt>18.14. <a href="#d5e935">Cross Methods</a></dt><dt>18.15. <a href="#d5e949">Axis Options</a></dt><dt>18.16. <a href="#d5e958">Axis Methods</a></dt><dt>18.17. <a href="#d5e972">Rectangle Options</a></dt><dt>18.18. <a href="#d5e984">Rectangle Methods</a></dt><dt>18.19. <a href="#d5e1001">BoundingBox Options</a></dt><dt>18.20. <a href="#d5e1013">BoundingBox Methods</a></dt><dt>18.21. <a href="#d5e1030">Grid Options</a></dt><dt>18.22. <a href="#d5e1059">CameraPrimitive Options</a></dt><dt>18.23. <a href="#d5e1068">CameraPrimitive Methods</a></dt><dt>18.24. <a href="#d5e1082">CameraPrimitive Options</a></dt><dt>18.25. <a href="#d5e1097">CameraPrimitive Methods</a></dt><dt>18.26. <a href="#d5e1117">Plane Options</a></dt><dt>18.27. <a href="#d5e1135">Plane Methods</a></dt><dt>18.28. <a href="#d5e1158">Cuboid Options</a></dt><dt>18.29. <a href="#d5e1182">Cuboid Methods</a></dt><dt>18.30. <a href="#d5e1214">Sphere Options</a></dt><dt>18.31. <a href="#d5e1226">Sphere Methods</a></dt><dt>18.32. <a href="#d5e1243">Torus Options</a></dt><dt>18.33. <a href="#d5e1258">Torus Methods</a></dt><dt>18.34. <a href="#d5e1278">Torus Options</a></dt><dt>18.35. <a href="#d5e1293">Torus Methods</a></dt><dt>18.36. <a href="#d5e1313">Cylinder Options</a></dt><dt>18.37. <a href="#d5e1334">Cylinder Methods</a></dt><dt>18.38. <a href="#d5e1360">Teapot Options</a></dt><dt>18.39. <a href="#d5e1372">Teapot Methods</a></dt><dt>18.40. <a href="#d5e1391">Camera Options</a></dt><dt>18.41. <a href="#d5e1418">Camera Methods</a></dt><dt>18.42. <a href="#d5e1447">FreeCamera Options</a></dt><dt>18.43. <a href="#d5e1477">RenderTargetBufferTexture Options</a></dt><dt>18.44. <a href="#d5e1491">Image2D Options</a></dt><dt>18.45. <a href="#d5e1527">Image2D Methods</a></dt><dt>18.46. <a href="#d5e1550">Image2D Options</a></dt><dt>18.47. <a href="#d5e1583">Image2D Methods</a></dt><dt>18.48. <a href="#d5e1615">CubeMap Options</a></dt><dt>18.49. <a href="#d5e1629">Video Options</a></dt><dt>18.50. <a href="#d5e1641">Image2D Methods</a></dt><dt>18.51. <a href="#d5e1655">Image2D Methods</a></dt><dt>18.52. <a href="#d5e1762">PointMaterial Options</a></dt><dt>18.53. <a href="#d5e1771">PointMaterial Methods</a></dt><dt>18.54. <a href="#d5e1788">LineMaterial Options</a></dt><dt>18.55. <a href="#d5e1797">LineMaterial Methods</a></dt><dt>18.56. <a href="#d5e1831">AnimationContainer Options</a></dt><dt>18.57. <a href="#d5e1840">AnimationContainer Methods</a></dt><dt>18.58. <a href="#d5e1857">TrackAnimationContainer Options</a></dt><dt>18.59. <a href="#d5e1866">TrackAnimationContainer Methods</a></dt><dt>18.60. <a href="#d5e1898">CharacterAnimationContainer Options</a></dt><dt>18.61. <a href="#d5e1907">CharacterAnimationContainer Methods</a></dt><dt>18.62. <a href="#d5e1940">CharacterAnimationContainer Methods</a></dt><dt>18.63. <a href="#d5e1995">SceneSerializer Options</a></dt><dt>18.64. <a href="#d5e2004">SceneSerializer Methods</a></dt><dt>18.65. <a href="#d5e2027">SceneDeserializer Options</a></dt><dt>18.66. <a href="#d5e2042">SceneDeserializer Methods</a></dt></dl></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title"><a name="d5e8"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e10">Installation</a></span></dt><dt><span class="section"><a href="#d5e15">What's Fabric Engine's SceneGraph?</a></span></dt><dt><span class="section"><a href="#d5e37">Abstraction of the Dependency Graph</a></span></dt><dt><span class="section"><a href="#d5e46">Scene Object and SceneGraphNode Construction</a></span></dt><dt><span class="section"><a href="#d5e58">Public and Private Interfaces</a></span></dt><dt><span class="section"><a href="#d5e65">Custom SceneGraphNodes and Inheritance</a></span></dt><dt><span class="section"><a href="#d5e68">The SceneGraph Debugger</a></span></dt></dl></div><div class="section" title="Installation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e10"></a>Installation</h2></div></div></div><p>
        Installation instructions can be found here: 
        
        <a class="link" href="http://documentation.fabric-engine.com/latest/FabricEngine-JSDeveloperInstallGuide.html" target="_top">
          <span class="quote">â<span class="quote">JS Developers Install Guide</span>â</span>
        </a>
        
      </p></div><div class="section" title="What's Fabric Engine's SceneGraph?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e15"></a>What's Fabric Engine's SceneGraph?</h2></div></div></div><p>The <span class="bold"><strong>SceneGraph</strong></span> is a wrapper for its counterpart, the
        Fabric Engine Core. Fabric Engine's core is a very low level system, providing the core
        objects such as a <span class="bold"><strong>Dependency Graph Node</strong></span>, <span class="bold"><strong>Operators</strong></span> and other elements. The <span class="bold"><strong>SceneGraph</strong></span> however is an abstraction layer for the core. It provides <span class="italic">presets</span> for Dependency Graph Node setups, called the
        SceneGraphNodes. The SceneGraph is purely implemented in JavaScript, and therefore can be
        customized easily for any specialized purpose.</p><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_introduction_01.png"></span></p><p>The SceneGraph is a factory which is used to create SceneGraphNodes. Each type of
        SceneGraphNode is registered with the SceneGraph on load. The factory function is
        responsible for constructing the underlying dependency graph, and returning an public
        interface. All data associated with the scene graph node is contained in the closure defined
        by the factory function. </p><p>A good understanding of closures and how they work in JavaScript is essential for
        understanding the Fabric SceneGraph.</p><p>The SceneGraph is provided as a series of JavaScript files which implement factory
        functions for a certain usage field, for example the file <span class="italic">Images.js</span> contains several factory functions implementing 2D images, 3D images
        and video SceneGraphNodes.</p><p>SceneGraphNodes encapsulate the core objects necessary to provide a certain
        functionality. The VideoNode, for example, contains the Dependency Graph Nodes to store all
        of the video related data, as well as all of the Operators to read and manipulate the video
        stream. Moreover it provides JavaScript functions to access and manipulate the video. </p><p><span class="bold"><strong>Managers</strong></span> are similar to SceneGraphNodes and are used
        mainly to provide utility functionality. One example of a manager is the UndoManager.
        Managers are genrally singletons, in that only on of each type of Manager is constructed. </p><p>The SceneGraph also provides graphical utilities, such as the <span class="bold"><strong>Debugger</strong></span>, which provides an graph based representation of the constructed core
        Dependency Graph. Other tools, for example the <span class="bold"><strong>Curve
        Editor</strong></span>, provide a graphical Curve editor for keyframe animation curves.</p></div><div class="section" title="Abstraction of the Dependency Graph"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e37"></a>Abstraction of the Dependency Graph</h2></div></div></div><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_introduction_02.png"></span></p><p>The goal of the SceneGraph layer is to present an interface to developers focused on
        SceneGraph construction. The interfaces exposed follow common SceneGraph conventions. </p><p>SceneGraphs can be setup in a few lines of code, and provide a rich array of features,
        from shader management and rendering, to manipulation and animation.</p><p>The SceneGraph is written entirely in JavaScript, and it abstracts the notion of the
        dependency graph away from the user. The JavaScript code assembles a lower level dependency
        graph. </p></div><div class="section" title="Scene Object and SceneGraphNode Construction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e46"></a>Scene Object and SceneGraphNode Construction</h2></div></div></div><p>The <span class="bold"><strong>scene</strong></span> provides basic services such as time
        management, and and is used to construct SceneGraphNodes.</p><p>
        </p><pre class="programlisting">var scene = FABRIC.SceneGraph.createScene();</pre><p>
      </p><p>The first SceneGraph object to be constructed is usually the scene object. The scene
        object creates a Fabric Engine context, a dependency graph node for containing globals, and
        some event handlers that are used in rendering. It returns a public interface which provides
        methods for constructing SceneGrapNodes. </p><p>All SceneGraphNode types implemented in the SceneGraph are registered by providing their
        type as well as a constructor function. A SceneGraphNode can be constructed iin the
        following way:</p><p>
        </p><pre class="programlisting">var sgNode = scene.constructNode('Image2D', { name: 'myImageNode' } );</pre><p>
      </p><p>The construction options supported by each SceneGraphNode can be found in the <span class="bold"><strong>SceneGraphNode Reference</strong></span> of this document. </p></div><div class="section" title="Public and Private Interfaces"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e58"></a>Public and Private Interfaces</h2></div></div></div><p>Each SceneGraphNode provides a private as well as a public interface. The public
        interface provide the public interface for the node. Outside of constructor functions it's
        only possible to access the public interface, while inside of constructor functions it's
        possible to access both the public and the private interface. This private interface enables
        exposing functions to tother nodes that request access to the private interface. Private
        interfaces expose methods that are used when building the underlying dependency graph. The
        public interface of a node should expose functions which define very high level behavior.
        For example, the sphere primitive exposes a public interface with methods to get and set the
        radius, and the private interface exposes methods to retrieve the core DGNodes that contain
        all the vertices. The public interface is what would be used to populte a graphical user
        interface for a node. Since the options used for the construction of a node can contain
        references to a public interface, you can retrieve the private interface by using this
        call:</p><pre class="programlisting">var privateInterface = scene.getPrivateInterface(publicInterface);</pre><p>To access the public interface from a private one, you simply need to access the
          <span class="italic">.pub</span> member of the private interface. Managers can also
        access private interfaces, allowing them to perform changes to the private data, for
        example.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> sgNode = {
  pub: {
    publicMethod: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span> () {}
  },
  privateMethod: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span> () {}
};</pre></div><div class="section" title="Custom SceneGraphNodes and Inheritance"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e65"></a>Custom SceneGraphNodes and Inheritance</h2></div></div></div><p>Applications can register their own, custom SceneGraphNodes. This can be useful and
        necessary when extending an existing node or providing a completely new one. In the
        constructor function of the custom node the other nodes can be accessed through their
        private interfaces, allowing access the inner workings of the SceneGraph. Each Scene Graph
        node extends the private or the public interface of its parent node type, enbling
        inheritance through composition. It is also possible to override an existing function on
        each interface by simply setting it to different function inside the custom node's
        constructor. For further details refer to the tutorials sections of this document.</p></div><div class="section" title="The SceneGraph Debugger"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e68"></a>The SceneGraph Debugger</h2></div></div></div><div class="mediaobject"><img src="images/JSSceneGraph/sg_debugger_01.png"></div><p>The debugger is a useful tool to inspect the dependency graph contructed by the
        SceneGraph. Especially when building custom SceneGraphNodes this can be very helpful. The
        debugger is described in more detail in the section on the Drawing Pipeline Guide in this
        document. You can open the debugger by using executing this code in JavaScript:</p><pre class="programlisting">FABRIC.displayDebugger();</pre></div></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;SceneGraph Type System"><div class="titlepage"><div><div><h2 class="title"><a name="d5e75"></a>Chapter&nbsp;2.&nbsp;SceneGraph Type System</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e83">Querying types</a></span></dt><dt><span class="section"><a href="#d5e91">JavaScript and KL</a></span></dt></dl></div><p>Fabric Engine enables you to define your own data structures. All data types in Fabric are
      define dynamically as part of the loading process of your application. To define the structure
      of data, you need to introduce <span class="bold"><strong>Types</strong></span>. Types are very similar
      to structs in C++. Core types, such as <span class="bold"><strong>Integer</strong></span>, <span class="bold"><strong>Boolean</strong></span> or <span class="bold"><strong>String</strong></span> are defined by the
      core. More complex types, such as the <span class="bold"><strong>Vec3</strong></span>, for example, are
      defined by the SceneGraph.</p><div class="section" title="Querying types"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e83"></a>Querying types</h2></div></div></div><p>You can access all of the currently registered types, by calling on the <span class="bold"><strong>RegisteredTypesManager</strong></span>. The manager is only accessible in the scope
        of a SceneGraphNode factory function, but you can access a dictionary of all current types
        by accessing the <span class="bold"><strong>RT</strong></span> object:</p><pre class="programlisting">console.log(FABRIC.RT);</pre><p>Types are typically implemented in separate JavaScript files. The ones provided by the
        SceneGraph can be found in the RT directory. The SceneGraph uses a <span class="bold"><strong>require</strong></span> framework which ensures that all required scripts are load into the
        application. You can find more details about this in the tutorials section of this document,
        covering the creation of a custom SceneGraphNode.</p></div><div class="section" title="JavaScript and KL"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e91"></a>JavaScript and KL</h2></div></div></div><p>Types can provide extra functionality both in JavaScript as well as Fabric Engine's
        kernel language (<span class="bold"><strong>KL</strong></span>). The type below implements an
          <span class="bold"><strong>Address</strong></span>, and implements both a JavaScript file as well as
        a KL file providing the additional functions, called the <span class="bold"><strong>bindings</strong></span>. The content of the JavaScript file looks like this: (the first array
        parameter is the list of requirements. this could include other types, for example.)</p><pre class="programlisting">FABRIC.define([], <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>() {

  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Constructor:</span>
  FABRIC.RT.Address = <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>(options) {
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span>(!options) options = {};
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.street = options.street != <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">undefined</span> ? options.street : <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>;
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.number = options.number != <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">undefined</span> ? options.number : <span class="hl-number">1</span>;
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.city = options.city != <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">undefined</span> ? options.city : <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>;
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.zip = options.zip != <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">undefined</span> ? options.zip : <span class="hl-number">1000</span>;
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.country = options.country != <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">undefined</span> ? options.country : <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">''</span>;
  };
  
  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Prototype, providing additional methods</span>
  FABRIC.RT.Address.<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">prototype</span> = {
    getPrintable: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>() {
      <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.street + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">' '</span> + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.number + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">' in '</span> + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.zip + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">' '</span> + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.city + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">', '</span> + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.country;
    }
  };
  
  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// Append this type to be loaded once the Fabric context exists</span>
  FABRIC.appendOnCreateContextCallback(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>(context) {
    context.RegisteredTypesManager.registerType(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Address'</span>, {
      members: {
        street: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'String'</span>, number: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Integer'</span>, city: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'String'</span>, zip: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Integer'</span>, country: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'String'</span>
      },
      constructor: FABRIC.RT.Address,
      klBindings: {
        filename: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Address.kl'</span>,
        sourceCode: FABRIC.loadResourceURL(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'RT/Address.kl'</span>)
      }
    });
  });

  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> FABRIC.RT.Address;
});</pre><p>The KL file mentioned in the appendOnCreateContextCallback above, <span class="bold"><strong>RT/Address.kl</strong></span> could look like this:</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">String</span> Address.getPrintable() {
  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.street + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">' '</span> + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.number + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">' in '</span> + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.zip + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">' '</span> + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.city + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">', '</span> + <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">this</span>.country;
}</pre><p>This will make the <span class="bold"><strong>getPrintable</strong></span> method available both
        in JavaScript as well as in KL. As you can see, you can specify any type of data. You can of
        course include custom types as members of other custom types, and therefore build very
        complex structures, which then can be used for computation inside the dependency graph or
        MapReduce.</p></div></div><div class="chapter" title="Chapter&nbsp;3.&nbsp;Kinematics Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e103"></a>Chapter&nbsp;3.&nbsp;Kinematics Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e105">Basic Transform</a></span></dt><dt><span class="section"><a href="#d5e117">Aimed Transform</a></span></dt></dl></div><div class="section" title="Basic Transform"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e105"></a>Basic Transform</h2></div></div></div><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_kinematics_01.png"></span></p><p>The SceneGraph's basic transform can represent a global or a hierarchical transform. It
        can be contructed like this:</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> globalTransform = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Transform'</span>, {
  hierarchical: false
});
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> hierarchicalTransform = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Transform'</span>, {
  hierarchical: true,
  parentTransformNode: globalTransform
});</pre><p>When contructed in global mode (hierarchical: false), the transform simply constructs
        global matrix based on the localXfo value. When contructed in hierarchical mode, a parent
        Transform node must also be provided. The transform node builds its global Xfo by
        multiplying the parent's global Xfo by its own local Xfo to get a new global Xfo.
        Hierarchies of transforms can be connected together to drive complex hierarchical
        animation.</p><p>When creating the transform node, you can specify the global or the local transform by
        providing a <span class="bold"><strong>FABRIC.RT.Xfo</strong></span>:</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> globalTransform = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Transform'</span>, {
  hierarchical: false,
  globalXfo: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Xfo({
    tr: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">1.0</span>, <span class="hl-number">2.0</span>, <span class="hl-number">3.0</span>)
  })
});</pre></div><div class="section" title="Aimed Transform"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e117"></a>Aimed Transform</h2></div></div></div><p>For the typical <span class="italic">lookat</span> behaviour of a transform, for
        example used for a camera with an lookat position, or a spot light with a target position,
        the SceneGraph provides a specialized transform node called the <span class="bold"><strong>AimTransform</strong></span>. It adds an additional option to the factory function, which
        allows you to specify the target position.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> aimTransform = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'AimTransform'</span>, {
  globalXfo: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Xfo({
      tr: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">1.0</span>, <span class="hl-number">2.0</span>, <span class="hl-number">3.0</span>)
  }),
  target: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">10.0</span>, <span class="hl-number">0.0</span>, <span class="hl-number">0.0</span>)
});</pre><p>The upvector direction used for the AimTransform is always the positive Y axis.</p></div></div><div class="chapter" title="Chapter&nbsp;4.&nbsp;Animation Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e124"></a>Chapter&nbsp;4.&nbsp;Animation Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e142">The Animation Controller node</a></span></dt><dt><span class="section"><a href="#d5e146">The TrackAnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e161">The CharacterAnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e172">Binding animation to target nodes</a></span></dt></dl></div><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_animation_01.png"></span></p><p>The animation pipeline in Fabric Engine's SceneGraph is inspired by the animation systems
      commonly found in game engines. The SceneGraphNodes in the animation pipeline are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="bold"><strong>AnimationController</strong></span></p></li><li class="listitem"><p><span class="bold"><strong>TrackAnimationContainer</strong></span></p></li><li class="listitem"><p><span class="bold"><strong>CharacterAnimationContainer</strong></span></p></li></ul></div><p>The evaluation of the animation is done in KL operators on the target nodes. In the image
      above the animation is driving a transform node, but any member on any kind of node can be
      driven by animation in Fabric Engine's SceneGraph.</p><div class="section" title="The Animation Controller node"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e142"></a>The Animation Controller node</h2></div></div></div><p>An Animation Controller is responsible for computing a time value from given inputs. The
        Animation Controller takes in a time paramter and uses it to compute a new time value. For
        example, an Animaiton Controller might take in global time and compute a, loop or ping-pong
        time value which is then used to drive an animation evaluation. A single controller can be
        used by many evaluators. The default Animation Controller node is bound to the globals
        SceneGraph node storing the global scene time.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> controller = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'AnimationController'</span>, {
  timeRange: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec2(<span class="hl-number">0.0</span>, <span class="hl-number">10.0</span>), <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// ten seconds</span>
  outOfRange: <span class="hl-number">1</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// looping</span>
});</pre></div><div class="section" title="The TrackAnimationContainer"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e146"></a>The TrackAnimationContainer</h2></div></div></div><p>Both the <span class="bold"><strong>TrackAnimationContainer</strong></span> as well as the
          <span class="bold"><strong>CharacterAnimationContainer</strong></span> inherit from the <span class="bold"><strong>AnimationContainer</strong></span>. The AnimationContainer SceneGraph node
        represents a container for any kind of animation. The TrackAnimationContainer uses a sliced
        dependency graph node to store many animation tracks in a single node. All tracks on the
        TrackAnimationContainer have to contain the same type of keys, which is why you can't
        construct a TrackAnimationContainer as is, you need to instantiate inherited nodes of it,
        such as the <span class="bold"><strong>LinearTrackAnimationContainer</strong></span> containing linear
        keys or <span class="bold"><strong>BezierTrackAnimationContainer</strong></span> containing bezier
        keys.</p><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_animation_02.png"></span></p><p>The TrackAnimationContainer represents a single animation of multiple tracks. The
        benefit of the TrackAnimationContainer is that tracks are stores in slices, and processing
        on the tracks can happen in a multi-threaded fashion.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> linearkey = <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>(time, value){ <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.LinearKeyframe(time, value); };

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> trackContainer = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'LinearTrackAnimationContainer'</span>, {});

trackContainer.addTrack(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.LinearKeyframeTrack(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'tr.x'</span>, FABRIC.RT.rgb(<span class="hl-number">1</span>, <span class="hl-number">0</span>, <span class="hl-number">0</span>), [
  linearkey(<span class="hl-number">0</span>, <span class="hl-number">0</span>), linearkey(<span class="hl-number">50</span>, <span class="hl-number">0</span>), linearkey(<span class="hl-number">75</span>, <span class="hl-number">50</span>), linearkey(<span class="hl-number">100</span>, <span class="hl-number">0</span>)
]));
trackContainer.addTrack(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.LinearKeyframeTrack(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'tr.y'</span>, FABRIC.RT.rgb(<span class="hl-number">0</span>, <span class="hl-number">1</span>, <span class="hl-number">0</span>), [
  linearkey(<span class="hl-number">0</span>, <span class="hl-number">0</span>), linearkey(<span class="hl-number">50</span>, <span class="hl-number">10</span>), linearkey(<span class="hl-number">75</span>, <span class="hl-number">00</span>), linearkey(<span class="hl-number">100</span>, <span class="hl-number">0</span>)
]));
trackContainer.addTrack(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.LinearKeyframeTrack(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'tr.z'</span>, FABRIC.RT.rgb(<span class="hl-number">0</span>, <span class="hl-number">0</span>, <span class="hl-number">1</span>), [
  linearkey(<span class="hl-number">0</span>, <span class="hl-number">0</span>), linearkey(<span class="hl-number">50</span>, <span class="hl-number">30</span>), linearkey(<span class="hl-number">75</span>, <span class="hl-number">00</span>), linearkey(<span class="hl-number">100</span>, <span class="hl-number">30</span>)
]));</pre><p>The code above create a small helper function for creating a linear key frame, then the
        track animation container is created. Once the container exists tracks can be pushed to it,
        providing the name of the track, a color for the UI as well as an array of keys for the
        track.</p></div><div class="section" title="The CharacterAnimationContainer"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e161"></a>The CharacterAnimationContainer</h2></div></div></div><p>The <span class="bold"><strong>CharacterAnimationContainer</strong></span> on the other hand is
        quite different from the TrackAnimationContainer. It stores a complete animation containing
        several tracks per slice, allowing to store a large number of complete animations on a
        single node. This container can be understood as a library of animations. Each animation is
        stored as a <span class="bold"><strong>TrackSet</strong></span>, which is essentially an array of
        tracks as well as a name for the TrackSet.</p><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_animation_03.png"></span></p><p>The CharacterAnimationContainer is used for the character pipeline, and will be
        discussed in more detail in the characters related section of this document. Essentially
        though, this is how you create a CharacterAnimationContainer:</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> linearkey = <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>(time, value){ <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.LinearKeyframe(time, value); };

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> characterContainer = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'LinearCharacterAnimationContainer'</span>, {});

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> walking = characterContainer.newTrackSet(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'walking'</span>);
walking.tracks.push(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.LinearKeyframeTrack(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'tr.x'</span>, FABRIC.RT.rgb(<span class="hl-number">1</span>, <span class="hl-number">0</span>, <span class="hl-number">0</span>), [
  linearkey(<span class="hl-number">0</span>, <span class="hl-number">0</span>), linearkey(<span class="hl-number">50</span>, <span class="hl-number">0</span>), linearkey(<span class="hl-number">75</span>, <span class="hl-number">50</span>), linearkey(<span class="hl-number">100</span>, <span class="hl-number">0</span>)
]));
walking.tracks.push(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.LinearKeyframeTrack(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'tr.y'</span>, FABRIC.RT.rgb(<span class="hl-number">0</span>, <span class="hl-number">1</span>, <span class="hl-number">0</span>), [
  linearkey(<span class="hl-number">0</span>, <span class="hl-number">0</span>), linearkey(<span class="hl-number">50</span>, <span class="hl-number">10</span>), linearkey(<span class="hl-number">75</span>, <span class="hl-number">00</span>), linearkey(<span class="hl-number">100</span>, <span class="hl-number">0</span>)
]));
walking.tracks.push(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.LinearKeyframeTrack(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'tr.z'</span>, FABRIC.RT.rgb(<span class="hl-number">0</span>, <span class="hl-number">0</span>, <span class="hl-number">1</span>), [
  linearkey(<span class="hl-number">0</span>, <span class="hl-number">0</span>), linearkey(<span class="hl-number">50</span>, <span class="hl-number">30</span>), linearkey(<span class="hl-number">75</span>, <span class="hl-number">00</span>), linearkey(<span class="hl-number">100</span>, <span class="hl-number">30</span>)
]));

characterContainer.addTrackSet(walking, [<span class="hl-number">0</span>,<span class="hl-number">1</span>,<span class="hl-number">2</span>]);</pre></div><div class="section" title="Binding animation to target nodes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e172"></a>Binding animation to target nodes</h2></div></div></div><p>To use the animation on a target node, such as a transform node, for example, you can
        call the <span class="bold"><strong>bindNodeMembersToTracks</strong></span> method of the animation
        container. You need to specify the target binding which includes the name of the member on
        the target node as well as the tracks that need to be bound to it. This you can drive
        complex types, as as a <span class="bold"><strong>Vec3</strong></span> for example, you can bind
        multiple tracks to the same member. In the case of a Vec3 the first track will go to the x
        component, the second track to the y component and so on.</p><pre class="programlisting">trackContainer.bindNodeMembersToTracks(transform, {
  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'globalXfo.tr'</span>: [<span class="hl-number">0</span>, <span class="hl-number">1</span>, <span class="hl-number">2</span>] <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// representing the tracks tr.x, tr.y and tr.z</span>
}, controller);</pre><p>Binding the animation on the target node will create an operator on the target's
        dependency graph node which evaluates the animation provided in the animation container and
        writes to the target node's member data. The operator also binds in the animation controller
        which was used during the construction of the animation container. If you don't provide a
        controller to the bindNodeMembersToTracks method the generated operator will simply bind to
        the global time. So in the case discussed in the code snippets in the animation guide, the
        resulting graph will look like this:</p><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_animation_04.png"></span></p></div></div><div class="chapter" title="Chapter&nbsp;5.&nbsp;Geometry Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e183"></a>Chapter&nbsp;5.&nbsp;Geometry Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e196">Anatomy of a Geometry Node</a></span></dt><dt><span class="section"><a href="#d5e210">Geometry Generation</a></span></dt><dt><span class="section"><a href="#d5e219">Geometry Services</a></span></dt><dt><span class="section"><a href="#d5e224">Geometry Data Copies</a></span></dt></dl></div><p>The geometry hierarchy in Fabric Engine's SceneGraph follows a classical inheritance
      model. Each node in the hierarchy adds functionality the the constructed SceneGraph node.
      Geometry can be created in several ways:</p><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_geometry_01.png"></span></p><p>1. A base geometry type can be constructed, and its geometry data can be populated from
      JavaScript:</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> geometryNode = scene.pub.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Triangles'</span>);
geometryNode.loadGeometryData({
  positions: [FABRIC.RT.vec3(<span class="hl-number">0</span>, <span class="hl-number">0</span>, <span class="hl-number">0</span>), FABRIC.RT.vec3(<span class="hl-number">0</span>, <span class="hl-number">0</span>, <span class="hl-number">1.0</span>), FABRIC.RT.vec3(<span class="hl-number">1.0</span>, <span class="hl-number">0</span>, <span class="hl-number">0</span>)], 
  indices: [<span class="hl-number">0</span>, <span class="hl-number">1</span>, <span class="hl-number">2</span>]
}); </pre><p>2. Geometry can be constructed by loading an external resource file, such as an OBJ file,
      for example:</p><pre class="programlisting">scene.importAssetFile(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Models/cow.obj'</span>,{ splitMaterials: true } );</pre><p>3. A primitive can be constructed. The primitive constructor assigns geometry generation
      operators which create all of the vertices and other data such as normals based on options on
      the primitive.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> primitiveNode = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Circle'</span>, { radius: <span class="hl-number">7</span> });</pre><div class="section" title="Anatomy of a Geometry Node"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e196"></a>Anatomy of a Geometry Node</h2></div></div></div><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_geometry_02.png"></span></p><p>A geometry SceneGraphNode contains several dependency graph nodes. Fabric Engine's
        slicing scheme is used to represent the data, and to allow high performance operations such
        as deformation on the geometry using multi-threading.</p><p>The <span class="bold"><strong>Uniforms</strong></span> node stores single values that are
        associated with the geometry, but don't vary per component. Primitives assign uniform values
        that are often exposed from the scene graph node as modifiable parameters. Triangles and
        Lines also store an array of Integers on the Uniforms node called <span class="bold"><strong>indexList</strong></span> which defines the connectivity of points for lines and
        triangles.</p><p>The <span class="bold"><strong>Attributes</strong></span> node stores all the âper-componentâ
        information. Attributes can easily be added and removed from geometry by simply adding and
        removing members from this node. The Attributes node is sliced, so the number of slices
        matches the number of vertices, for example.</p><p>The <span class="bold"><strong>BoundingBox</strong></span> node is generated using the attributes,
        and is used to accelerate interaction with the geometry such as raycasting.</p></div><div class="section" title="Geometry Generation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e210"></a>Geometry Generation</h2></div></div></div><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_geometry_03.png"></span></p><p>Note: this are will be re-structured slightly once we have support for node
        nesting.</p><p>The purpose of a generator operator is to generate the vertex information that is stored
        in the attributes node, and the indexList (for Triangles and Lines), which is stored in the
        âUniformsâ node. First we calculate the number of vertices in the <span class="bold"><strong>setCount</strong></span> operator, and then populate the attributes node in the second
        operator. The second operator also writes the indexList which is stored on the Uniforms
        node.</p></div><div class="section" title="Geometry Services"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e219"></a>Geometry Services</h2></div></div></div><p>A key service that the the Geometry node provides is integration with the rendering
        pipeline. The design of Fabric Engine's SceneGraph is based heavily on OpenGL shading
        language GLSL, and all rendering in the OpenGL viewport is performed via shaders. </p><p>The geometry node constructs an event handler and binds operators to it for loading all
        the various vertex attributes into the GPU and storing the buffer ids. This means that you
        can add a new vertex attributes to a geometry, then use that data in a shader and the
        geometry node will take care of loading the data so it is ready for the shader. This is
        discussed in more detail in the <span class="bold"><strong>Drawing Pipeling Guide</strong></span>
        section of this document.</p></div><div class="section" title="Geometry Data Copies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e224"></a>Geometry Data Copies</h2></div></div></div><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_geometry_04.png"></span></p><p>Geometry data copies provide a way to split the definition of a rendered geometry into
        multiple sections. A Geometry data copy is used to extend a base geometry, usually by adding
        deformation operators. The base geometry represents the original undeformed geometry, and
        the data copy is used to apply changes. The Geometry data does not contain a complete
        description of gometry, but only the the data that is a modification of the base geometry.
        During rendering, uniforms and attributes are loaded from the base geometry and the data
        copy where any attributes in the data copy verride the attributes in the base
        geometry.</p><p>Since the Attributes node is sliced, deformation can be performed using
        multi-threading.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> geometryCopyNode = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'GeometryDataCopy'</span>, {baseGeometryNode: geometryNode} );
geometryCopyNode.addVertexAttributeValue(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'positions'</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Vec3'</span>, { genVBO:true, dynamic:true } );</pre><p>Note: The <span class="italic">PerPointDeformation.html</span> sample application
        contains an example of this.</p></div></div><div class="chapter" title="Chapter&nbsp;6.&nbsp;Parsers Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e235"></a>Chapter&nbsp;6.&nbsp;Parsers Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e238">The OBJ Parser</a></span></dt><dt><span class="section"><a href="#d5e248">The Collada Parser</a></span></dt><dt><span class="section"><a href="#d5e267">The Alembic Parser</a></span></dt></dl></div><p>Fabric Engine's SceneGraph comes with several parsers for importing external resource
      files. Since the loading of external data happens asynchronously, you will need to provide
      callback functions to the parsers, which will executed once the content is loaded, parsed and
      ready for use. Parsers are automatically invoked and chosen based on the file extension of the
      resource to load.</p><div class="section" title="The OBJ Parser"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e238"></a>The OBJ Parser</h2></div></div></div><p>The OBJ file format can store polygonal meshes with UV coordinates as well as basic
        material settings. You can use the OBJ parser like this:</p><pre class="programlisting">scene.importAssetFile(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Models/cow.obj'</span>, {splitMaterials: false}, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>(assetNodes) {
  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span>(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> name <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">in</span> assetNodes) {
    console.log(assetNodes[name]);
  }
});</pre><p>The last argument to the <span class="bold"><strong>importAssetFile</strong></span> method is the
        callback function to execute once the parsed result is ready for consumption. The OBJ parser
        returns a dictionary of triangle geometry nodes representing all of the geometries which are
        part of the OBJ file. If the <span class="bold"><strong>splitMaterials</strong></span> option is set
        to true, the Obj parser will splith the geometries into multiple geometry sets according to
        the material assignments in the file.  Each returned geometry can then be assigned  separate
        materials for rendering.</p><p>Note: The <span class="italic">ModelViewer.html<span class="bold"><strong> </strong></span></span>sample application contains an example of the OBJ parser in
        use.</p></div><div class="section" title="The Collada Parser"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e248"></a>The Collada Parser</h2></div></div></div><p>Collada's DAE file format can store complex types of data, including polygonal meshes,
        transform hierarchies, point clouds as well as other complex 3D data structures. The
        SceneGraph's collada parser currently supports:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Polygonal Meshes including UV coordinates and skinning weights, imported as
              Triangles nodes</p></li><li class="listitem"><p>Character Hierarchies used for skinning, imported as CharacterRig nodes</p></li><li class="listitem"><p>FCurve animation on hierarchies, imported as CharacterAnimationContainer
              nodes</p></li><li class="listitem"><p>Cameras including focal length and aperture settings, imported as Camera
              nodes</p></li></ul></div><p>The Collada parser can be invoked like this:</p><pre class="programlisting">scene.importAssetFile(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Models/character.dae'</span>, {
    constructRigFromHierarchy: true
}, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>(assetNodes) {
  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span>(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> name <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">in</span> assetNodes) {
    console.log(assetNodes[name]);
  }
});</pre><p>The last argument of the parser's invocation is a callback function to be called once
        the collada data is parsed and ready for consumption. In the example above we simply log the
        data to the console. For further details on the character related nodes please see the
          <span class="bold"><strong>Character Guide</strong></span> section of this document.</p><p>Note: The <span class="italic">CharacterSkeleton.html<span class="bold"><strong> </strong></span></span>sample application contains an example of the Collada parser in
        use.</p></div><div class="section" title="The Alembic Parser"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e267"></a>The Alembic Parser</h2></div></div></div><p>Alembic ABC file format can store several kinds of data. The SceneGraph's Alembic
        intergration currently supports:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Polygonal Meshes including UV coordinates and normals, imported as Triangle
              nodes</p></li><li class="listitem"><p>Curve lists including width and color values, imported as Lines nodes</p></li><li class="listitem"><p>Cameras with proper focal length and aperture settings, imported as Camera
              nodes</p></li><li class="listitem"><p>Point clouds including full transform support, color values, imported as Points
              nodes</p></li></ul></div><p>Since Alembic stores animation as discrete samples the parser doesn't load all of the
        data to memory, but rather constructs operators which re-evaluate based on time changes.
        This way animation can be loaded into Fabric Engine and synchronized with the SceneGraph's
        global time or a different AnimationController.</p><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_parsers_01.png"></span></p><p>The Alembic resource node holds what is called a <span class="bold"><strong>AlembicHandle</strong></span> to the original resource file, which is forwarded through the
        dependency graph and used by all of the ABC operators to pull the relevant data out of the
        Alembic file. Per se there is no parsing happening in JavaScript, so once the resource is
        loaded, the <span class="bold"><strong>loadSuccess</strong></span> event fires. The sample code below
        shows how to load data from an Alembic resource. For more details on event handling please
        refer to the <span class="bold"><strong>Event Guide</strong></span> section of this document.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> alembicLoadNode = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'AlembicLoadNode'</span>, {
  url: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Models/cow.abc'</span>
});
alembicLoadNode.addEventListener(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loadSuccess'</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>(){
  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> assetNodes = alembicLoadNode.getParsedNodes(); 
  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span>(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> name <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">in</span> assetNodes) {
    console.log(assetNodes[name]);
  }
});</pre><p>Note: The <span class="italic">Alembic/Primitives.html<span class="bold"><strong> </strong></span></span>sample application contains an example of the Alembic parser in
        use.</p></div></div><div class="chapter" title="Chapter&nbsp;7.&nbsp;Characters Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e292"></a>Chapter&nbsp;7.&nbsp;Characters Guide</h2></div></div></div><p>This is do be done for Phil!</p></div><div class="chapter" title="Chapter&nbsp;8.&nbsp;Images and Video Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e295"></a>Chapter&nbsp;8.&nbsp;Images and Video Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e298">Anatomy of an Image node</a></span></dt><dt><span class="section"><a href="#d5e307">Loading 2D Images</a></span></dt><dt><span class="section"><a href="#d5e322">Loading 3D Images</a></span></dt><dt><span class="section"><a href="#d5e332">Loading Video</a></span></dt></dl></div><p>The SceneGraph supports reading and using external image resource files as well as
      external video streams. Typically images are never loaded onto dependency graph nodes or
      stored in the main memory, they are rather pushed directly to the GPU. When drawing textures
      there is no need to keep the image in the RAM, however if you want to modify the image using
      the CPU the images has to be stored in the dependency graph. Fabric Engine supports 2D images
      as well as 3D images.</p><div class="section" title="Anatomy of an Image node"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e298"></a>Anatomy of an Image node</h2></div></div></div><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_images_01.png"></span></p><p>Similar to the Geometry node, an image node is split into two dependency graph nodes.
        The <span class="bold"><strong>Uniforms</strong></span> node stores all of the non-per-pixel data,
        such as the width and height of the image. These values are typically exposed to the
        SceneGraph node as getter function. The <span class="bold"><strong>Attributes</strong></span> node
        contains the per pixel data, however only if the Attributes dependency node is required at
        all. As mentioned above the per pixel data is normally directly pushed to the GPU.</p></div><div class="section" title="Loading 2D Images"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e307"></a>Loading 2D Images</h2></div></div></div><p>Currently the SceneGraph supports loading 2d images of the types <span class="bold"><strong>JPG</strong></span>, <span class="bold"><strong>PNG</strong></span>, <span class="bold"><strong>BMP</strong></span>, <span class="bold"><strong>TIF</strong></span>, <span class="bold"><strong>EXR</strong></span>, and <span class="bold"><strong>HDR</strong></span>. The last two are stores as
        floating point images, while the other formats are stored as byte images. 2d images are
        always stored as RGBA, even if the original image data doesn't contain an alpha
        channel.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> image2D = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Image2D'</span>, {
  url: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Resources/tomatoes_960_640.png'</span>,
  createDgNodes: false
});</pre><p>If you want the image to be loaded into the RAM and accessible in the dependency graph,
        you need to set the <span class="bold"><strong>createDgNodes</strong></span> option to true. You can
        then attach operators to the Attributes node to perform per pixel calculations in a
        multi-threaded fashion.</p><p>Note: The <span class="italic">BackgroundTexture.html<span class="bold"><strong> </strong></span></span>sample application contains a simple example of an image node in
        use.</p></div><div class="section" title="Loading 3D Images"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e322"></a>Loading 3D Images</h2></div></div></div><p>Currently the SceneGraph only supports loading 3d images of the type <span class="bold"><strong>NRRD</strong></span>. 3d images are always stored as USHORT with RGBA
        channels.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> image3D = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Image3D'</span>, {
  url: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Resources/threed_texture.nrrd'</span>,
  createDgNodes: false
});</pre><p>As with 2d iamges, if you want the image to be loaded into the RAM and accessible in the
        dependency graph, you need to set the <span class="bold"><strong>createDgNodes</strong></span> option
        to true.</p><p>Note: The <span class="italic">MedicalImaging.html<span class="bold"><strong> </strong></span></span>use-case application contains an example of a 3d image node in
        use.</p></div><div class="section" title="Loading Video"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e332"></a>Loading Video</h2></div></div></div><p>Video nodes are pretty much the same as Image2D nodes, except that they have operators
        attached which pull frames out of the external video file resource. For that, the current
        frame is stored on the Attributes dependency graph node and is constantly pushed to the GPU
        if the time of the video changes. Fabric Engine utilizes the <span class="bold"><strong>FFMPEG</strong></span> library to offer support for a wide variety of video formats. Aside
        from other formats, the SceneGraph's video node supports: <span class="bold"><strong>AVI</strong></span>, <span class="bold"><strong>MOV</strong></span> and <span class="bold"><strong>MP4</strong></span>. </p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> videoNode = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Video'</span>, {
  url: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Resources/bee_960.mov'</span>,
  loop: true
});</pre><p>Note: The <span class="italic">Video.html<span class="bold"><strong> </strong></span></span>sample application contains a simple example of a video node in
        use.</p></div></div><div class="chapter" title="Chapter&nbsp;9.&nbsp;Drawing Pipeline Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e343"></a>Chapter&nbsp;9.&nbsp;Drawing Pipeline Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e346">Predescend and Postdescend</a></span></dt><dt><span class="section"><a href="#d5e357">Windows</a></span></dt><dt><span class="section"><a href="#d5e368">Setting up the Viewport in OpenGL</a></span></dt><dt><span class="section"><a href="#d5e375">Shaders</a></span></dt><dt><span class="section"><a href="#d5e387">GLSL Uniforms and Attributes</a></span></dt><dt><span class="section"><a href="#d5e392">Materials</a></span></dt><dt><span class="section"><a href="#d5e396">Textures</a></span></dt><dt><span class="section"><a href="#d5e405">Instances</a></span></dt><dt><span class="section"><a href="#d5e427">Shadows</a></span></dt></dl></div><p>Fabric Engine's SceneGraph's drawing pipeline is very flexible and customizable. Drawing
      is performed with as few operations as possible providing high performance rendering.
      Generally is is important to understand that drawing invokes the evaluation of the dependency
      graph.</p><div class="section" title="Predescend and Postdescend"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e346"></a>Predescend and Postdescend</h2></div></div></div><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_drawing_01.png"></span></p><p>The drawing pipline is implemented using eventhandlers. The eventhandler tree for
        drawing listens to the paint event of the canvas resp. the windows. The drawing pipeline
        evaluates in two phases: the <span class="bold"><strong>Predescend</strong></span> and <span class="bold"><strong>Postdescent</strong></span>. Predescend happens when the drawing pipline evaluates
        each event handler from left to right, resp. from the event down to the last eventhandler.
        Postdescend happens once the descend is done, traveling through the event graph back up to
        the event. Operators for drawing can be applied on either the <span class="bold"><strong>preDescendBindings</strong></span> or the <span class="bold"><strong>postDescendBindings.</strong></span> When each eventhandler evaluates it pulls on the
        connected dependency graph nodes. If the dependency graph node itself has dependencies and
        operators, the execution of the dependencies and operatos will be fired.</p></div><div class="section" title="Windows"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e357"></a>Windows</h2></div></div></div><p>Each window in Fabric defines a dependency graph node and an Event. The node contains
        data about the window such as its width and height, and the event is fired when painting of
        the window is required. The width and height values are driven by the Fabric plugin, and are
        updated when the window is resized.</p><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_drawing_02.png"></span></p><p>The Window Event node is an event that is fired whenever the window needs painting. This
        may occur because the window was resized, revealed, or invalidated in any way. It is also
        possible to manually trigger a redraw from JavaScript. Redrawing of the window during
        animation is effected by modifying graph variables such as time, and then manually
        triggering a redraw. The JavaScript mechanism to fire a redraw manually is accessible
        through the <span class="bold"><strong>Viewport</strong></span> node.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> viewport = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Viewport'</span>, {
  windowElement: document.getElementById(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'FabricContainer'</span>) <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// provide the HTML element for the viewport</span>
});
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// fire a redraw manually</span>
viewport.redraw();</pre><p>By attaching event handlers to the Window Paint Event node, we can coordinate the
        drawing of the window using OpenGL. The OpenGL context is set up and bound prior to the
        paint event being fired. For more information on Events, and Event Handlers, please consult
        the Core Programming Guide.</p></div><div class="section" title="Setting up the Viewport in OpenGL"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e368"></a>Setting up the Viewport in OpenGL</h2></div></div></div><p>When the window redraw event is fired, the subgraph is traversed, first visiting the
        Viewport event handler which has an operator attached called <span class="bold"><strong>viewPortBeginRender</strong></span>. When viewPortBeginRender is executed, the initial OpenGL
        parameters are set.</p><pre class="programlisting">operator viewPortBeginRender(io Integer width, io Integer height, io Color backgroundColor) {   
  glCullFace(GL_BACK);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);   glViewport(0, 0, width, height);
  glClearColor(backgroundColor.r,
  backgroundColor.g, backgroundColor.b, backgroundColor.a);
  glClear(GL_COLOR_BUFFER_BIT |
  GL_DEPTH_BUFFER_BIT);
}</pre><p>The camera event handler is then visited, where the camera projection values are
        computed in the operator <span class="bold"><strong>updateCameraProjection</strong></span>.</p></div><div class="section" title="Shaders"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e375"></a>Shaders</h2></div></div></div><p>The Fabric SceneGraph rendering system breaks shaders into 2 components, <span class="bold"><strong>shaders</strong></span> and <span class="bold"><strong>materials</strong></span>. The shader
        event handler loads the shader source into the OpenGL driver and compiles the shader
        program. The specification of the shader also includes some meta-data such as the buffers
        required by the shader, and any constant values that must be defined. </p><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_drawing_03.png"></span></p><p>Note: To inspect the drawing pipeline you can use the SceneGraph's debugger. Just open
        the <span class="italic">ModelViewer.html</span> sample application, for example,
        open the JavaScript console, and type:</p><pre class="programlisting">FABRIC.displayDebugger();</pre></div><div class="section" title="GLSL Uniforms and Attributes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e387"></a>GLSL Uniforms and Attributes</h2></div></div></div><p>GLSL shaders define a set of parameters which must be filled out before the geometry can
        be drawn on screen. These 2 sets of requirements are stored in 2 arrays called
        attributeValues, and uniformValues. These arrays are accessible by all child event handlers
        who can determine what data is required by the shader.</p><p>
        <span class="italic">Note: the design of the event handler graph means that 2 different
          nodes can define the same data under the same 'scope name', and the order of visitation
          defines which scope is valid. This enables a single geometry to be rendered multiple times
          using different shaders.</span>
      </p></div><div class="section" title="Materials"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e392"></a>Materials</h2></div></div></div><p>Materials define parameters for the shader program and is used to attach image loaders.
        The Material node in Fabric Engine is generated using meta data associated with the shader.
        XML files are loaded which contain both the GLSL shader code, and meta data that instructs
        the rendering system how to construct material node instances.</p><p>Materials provide data to the shader such as shading parameters, and also provide a
        branch point in the event graph where textures can be loaded and bound prior to traversal
        continuing to the Instance node.</p></div><div class="section" title="Textures"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e396"></a>Textures</h2></div></div></div><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_drawing_04.png"></span></p><p>Materials which utilize textures must specify which <span class="bold"><strong>textureUnit</strong></span> to assign each texture. This process is automated using the
        material system in the SceneGraph. For each textureUnit, a <span class="bold"><strong>stub</strong></span> node is generated. This stub node binds in the texture unit that will be
        assigned to the texture. This allows multiple textures to be used on the same material, and
        textures to be shared amongst materials. </p></div><div class="section" title="Instances"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e405"></a>Instances</h2></div></div></div><p>The <span class="bold"><strong>instance</strong></span> node represents a drawn piece of geometry.
        To be able to draw geometry on screen, several things bust have happened prior to the draw
        call.</p><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_drawing_05.png"></span></p><p>Geometry rendering happens in the following order:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The shader program is loaded</p></li><li class="listitem"><p>The the material node is traversed and shader constants set</p></li><li class="listitem"><p>From the material traversal may continue into the texture stubs and on into the
              texture nodes where the textures are loaded. </p></li><li class="listitem"><p>From the material node, traversal continues down to the instance node, where the
              matrix for the draw is loaded.</p></li><li class="listitem"><p>From the instance node, traversal continues down to the geometry node where the
              geometry buffers are loaded and shader uniforms may also be set.</p></li><li class="listitem"><p>The Geometry is a leaf node, and after the preDescendBindings have been evaluated
              the postDescendBindings follow immediately, and the draw call is executed.</p></li></ol></div></div><div class="section" title="Shadows"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e427"></a>Shadows</h2></div></div></div><p>Shadow maps are rendered in a pre-draw stage prior to the camera render pass. For each
        light, we render the scene from the point of view of the light, and store the depth
        information in a depth buffer. The depth buffer ID is stored in the light node which is also
        bound to the material. This gives the material access to the lights shadow buffers, enabling
        the correct shadowing of geometry.</p><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_drawing_06.png"></span></p><p>The red arrow in the diagram represents a binding from the light to the material. This
        binding is what gives the material access to the light's shadow buffer.</p></div></div><div class="chapter" title="Chapter&nbsp;10.&nbsp;Deferred Rendering Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e435"></a>Chapter&nbsp;10.&nbsp;Deferred Rendering Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e445">Setting up the Deferred Renderer</a></span></dt><dt><span class="section"><a href="#d5e454">PrePass Deferred Shaders</a></span></dt><dt><span class="section"><a href="#d5e458">PostPass Deferred Shaders</a></span></dt></dl></div><p>Deferred rendering describes the process of drawing the viewport's content to several
      framebuffers, and then doing additional passes of rendering utilizing these framebuffers.
      Deferred rendering is tremendously different from standard rendering, since all of the GLSL
      shaders have to store their resulting pixel values into framebuffers. So shaders have to be
      specifically written for deferred rendering.</p><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_deferred_01.png"></span></p><p>Deferred rendering allows to perform 2D post effects on the GPU, or additional 3D
      rendering as a post effect.</p><p>Note: The <span class="italic">ToonRendering.html</span> sample applications
      contains an example of using the deferred renderer.</p><div class="section" title="Setting up the Deferred Renderer"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e445"></a>Setting up the Deferred Renderer</h2></div></div></div><p>The SceneGraph provides a utility node called the <span class="bold"><strong>BasicDeferredRenderer</strong></span>. </p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> renderer = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BasicDeferredRenderer'</span>, {
  addDepth: false, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// don't add a depth framebuffer</span>
  colorBuffers: [{name: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'diffuseA, nbChannels: 4}, {name: '</span>diffuseB<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">', nbChannels: 4}]
</span>});</pre><p>Once the renderer is setup, you can setup materials through it. This will ensure that
        the shader and material eventhandlers are connected up correctly within the drawing
        pipeline. You can create <span class="bold"><strong>prePassMaterials</strong></span> (for the initial
        draw into framebuffers) or <span class="bold"><strong>postPassMaterials</strong></span> (for the
        deferred draw utilizing the framebuffers).</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> drawMaterial = renderer.addPrePassMaterial(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'MyDeferredShader'</span>, {});
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> compositingMaterial = renderer.addPostPassMaterial(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'MyCompositingShader'</span>, {});</pre></div><div class="section" title="PrePass Deferred Shaders"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e454"></a>PrePass Deferred Shaders</h2></div></div></div><p>Shaders for a deferred rendering pipline have to write their results in the fragment
        data in GLSL. This will fill the framebuffers. You need to setup the framebuffers
        accordingly when constructing the deferred renderer node. Prepass deferred shaders replace
        the standard shaders from a non-deferred drawing pipeline. Here's an example of a small
        fragment shader that writes red to the first and blue to the second framebuffer.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(){
  gl_FragData[<span class="hl-number">0</span>] = vec4(<span class="hl-number">1.0</span>,<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>,<span class="hl-number">1.0</span>);
  gl_FragData[<span class="hl-number">1</span>] = vec4(<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>,<span class="hl-number">1.0</span>,<span class="hl-number">1.0</span>);
}</pre></div><div class="section" title="PostPass Deferred Shaders"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e458"></a>PostPass Deferred Shaders</h2></div></div></div><p>PostPass deferred shaders perform the <span class="bold"><strong>compositing</strong></span> of
        the framebuffers to the final displayed image. Typically postpass shaders perform per pixel
        compositing, but they can access all pixels of the framebuffers, since the framebuffers are
        stored as textures on the GPU. Here's an example of a fragment shader which combines both
        diffuse color from the deferred renderer above:</p><pre class="programlisting">uniform sampler2D u_samplerDiffuseA;
uniform sampler2D u_samplerDiffuseB;

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">void</span> main(){
  vec2 windowCoord = gl_TexCoord[<span class="hl-number">0</span>].st*<span class="hl-number">0.5</span>+<span class="hl-number">0.5</span>;
  gl_FragColor = texture2D( u_samplerDiffuseA, windowCoord ) + texture2D( u_samplerDiffuseB, windowCoord ); 
}</pre><p>This will result in a violet rendering of the 3D scene, combined from two different draw
        results.</p><p>Note: Please also see the <span class="italic">DeferredRendering.html</span>
        sample application for an example of a more advanced scenario.</p></div></div><div class="chapter" title="Chapter&nbsp;11.&nbsp;SceneGraph IO Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e466"></a>Chapter&nbsp;11.&nbsp;SceneGraph IO Guide</h2></div></div></div><p>Waiting for Jerome's input...!</p></div><div class="chapter" title="Chapter&nbsp;12.&nbsp;Events Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e469"></a>Chapter&nbsp;12.&nbsp;Events Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e472">Setting up a node for event handling</a></span></dt><dt><span class="section"><a href="#d5e490">loadSuccess event</a></span></dt></dl></div><p>The SceneGraph provides a system for automatically firing callbacks when certain things
      happen. SceneGraph events are a very powerful mechanism to automate functionality, especially
      since in web applications things can happen asynchronously.</p><div class="section" title="Setting up a node for event handling"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e472"></a>Setting up a node for event handling</h2></div></div></div><p>To enable events on a SceneGraph node the <span class="bold"><strong>addEventHandlingFunctions</strong></span> method has to be called in the constructor of the
        node.</p><pre class="programlisting">scene.addEventHandlingFunctions(myNodePrivateInterface);</pre><p>Once that's done the node can fire events and receive event callbacks. To attach a
        callback to the node, other nodes resp. the scene script can call the <span class="bold"><strong>addEventListener</strong></span> method.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> myCallback = <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>(evt) {
  console.log(evt);
  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'remove'</span>;
};
myNodePublicInterface.addEventListener(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myEvent'</span>, myCallback);</pre><p>If the event callback function returns <span class="italic">'remove'</span> the
        callback will be removed from the event listener stack, and won't fire again if the element
        fires another time. If you don't return <span class="italic">'remove'</span> the
        callback will stay attached.</p><p>You can also remove the event callback by calling the <span class="bold"><strong>removeEventListener</strong></span> method, which allows to have functions listens to event
        dynamically. So to say you can attach functions and de-attach them again.</p><pre class="programlisting">myNodePublicInterface.removeEventListener(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myEvent'</span>, myCallback);</pre><p>To trigger the event programatically you can call the <span class="bold"><strong>fireEvent</strong></span> method on the node. </p><pre class="programlisting">myNodePublicInterface.fireEvent(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myEvent'</span>, { data: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myData'</span> });</pre><p>This fires all attached event callbacks, and provides the event data to each of the
        callback functions.  This mechasnism is used heavily throughout the SceneGraph.</p></div><div class="section" title="loadSuccess event"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e490"></a>loadSuccess event</h2></div></div></div><p>The <span class="bold"><strong>ResourceLoadNode</strong></span>, covered in the <span class="bold"><strong>SceneGraph IO Guide</strong></span> in this document, uses events to dispatch the
        call of event listeners once a resource file is loaded. This mechanism is uses in the
        SceneGraph parsers, but you can also use it for custom scenarios like this:</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> resourceLoadNode = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'ResourceLoad'</span>, {
  url: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myBinaryFile.bin'</span>
});
resourceLoadNode.addEventListener(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'loadSuccess'</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>(evt){
  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// attach operators to the resourceLoadNode for parsing...</span>
  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">return</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'remove'</span>;
});</pre><p>This allows you to automatically continue with the setup of the application once the
        resource file is downloaded and ready.</p></div></div><div class="chapter" title="Chapter&nbsp;13.&nbsp;Selection Manager Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e497"></a>Chapter&nbsp;13.&nbsp;Selection Manager Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e502">Basic Selection Management</a></span></dt><dt><span class="section"><a href="#d5e506">Viewport Selection Manager</a></span></dt><dt><span class="section"><a href="#d5e522">Selection Manipulation Manager</a></span></dt></dl></div><p>The SceneGraph comes with a manager for selection, called the <span class="bold"><strong>SelectionManager</strong></span>. This manager is the basic implementation, and simply keeps
      track of a collection of selected nodes. It provides the <span class="bold"><strong>selectionChanged</strong></span> event for automating UI changes, for example, based on the
      selection.</p><div class="section" title="Basic Selection Management"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e502"></a>Basic Selection Management</h2></div></div></div><p>The code snippet below sets up the manager, attaches a callback to it and selects as
        well as deselects a single node. This code is the basis for more complex selection
        management.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// setup manager and attach event callback</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> selectionMgr = scene.constructManager(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'SelectionManager'</span>);
selectionMgr.addEventListener(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'selectionChangesd'</span>,<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>(evt) {
  console.log(evt.selection);
});

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// select a node and deselect it again</span>
selectionMgr.addToSelection(myNode);
selectionMgr.removeFromSelection(myNode);</pre></div><div class="section" title="Viewport Selection Manager"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e506"></a>Viewport Selection Manager</h2></div></div></div><p>The <span class="bold"><strong>ViewportSelectionManager</strong></span> works by providing a new
          <span class="bold"><strong>Instance</strong></span> node, called the <span class="bold"><strong>SelectableInstance</strong></span>. It contains a selection state as well as an additional
        material, that indicates the selection during drawing.</p><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_selection_01.png"></span></p><p>When a SelectableInstance node is hovered, the material on the node changes to the
          <span class="italic">highlighted</span> material. Once the node is selected the
        material changes to the <span class="italic">selected</span> material. </p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create the materials</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> normalMaterial = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'FlatMaterial'</span>, { color: FABRIC.RT.rgb(<span class="hl-number">0.0</span>, <span class="hl-number">0.0</span>, <span class="hl-number">1.0</span>, <span class="hl-number">1</span>) });
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> highlightMaterial = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'FlatMaterial'</span>, { color: FABRIC.RT.rgb(<span class="hl-number">0.7</span>, <span class="hl-number">0.7</span>, <span class="hl-number">0.7</span>, <span class="hl-number">1</span>) });
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> selectedMaterial = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'FlatMaterial'</span>, { color: FABRIC.RT.rgb(<span class="hl-number">1.0</span>, <span class="hl-number">0.0</span>, <span class="hl-number">0.0</span>, <span class="hl-number">1</span>) });

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create a selectable instance</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> myInstance = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'SelectableInstance'</span>, {
  transformNode: myTransform,
  geometryNode: myGeometry,
  materialNode: normalMaterial,
  highlightMaterial: highlightMaterial,
  selectMaterial: selectedMaterial
});

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// setup manager and attach event callback</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> selectionMgr = scene.constructManager(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'ViewportSelectionManager'</span>);
selectionMgr.addEventListener(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'selectionChangesd'</span>,<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>(evt) {
  console.log(evt.selection);
});

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// select a node and deselect it again</span>
selectionMgr.addToSelection(myInstance);
selectionMgr.removeFromSelection(myInstance);</pre><p><span class="italic">Note: The Selection.html sample application contains an example
          of how to use selection in the SceneGraph.</span></p></div><div class="section" title="Selection Manipulation Manager"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e522"></a>Selection Manipulation Manager</h2></div></div></div><p>The <span class="bold"><strong>SelectionManipulationManager</strong></span> provides an additional
        mechanism for selection based manipulation. For further details on the way manipulation
        works in the SceneGraph please refer to the <span class="bold"><strong>Manipulation
          Guide</strong></span> in this document. The SelectionManipulationManager itself is not taking
        care of the selection management, therefore you need to specify the SelectionManager during
        its construction. The SelectionManipulationManager just takes care of setting up a group
        manipulation, that toggles on and off based on selection changes as well as centers the
        manipulator in the center of the selected objects.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> manipulationMgr = scene.constructManager(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'SelectionManipulationManager'</span>, {
  selectionManager: selectionMgr,
  manipulators: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">undefined</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// here you can specify an array of manipulators to manage</span>
});</pre><p>By providing a list of manipulators to the <span class="italic">manipulators</span> option, you can define the kind of manipulations you want the
        manager to take care of. If you don't specify anything, the manipulation will default to to
        a screen space translation.</p></div></div><div class="chapter" title="Chapter&nbsp;14.&nbsp;Manipulation Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e530"></a>Chapter&nbsp;14.&nbsp;Manipulation Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e542">Setting up a Manipulator</a></span></dt></dl></div><p>The SceneGraph provides a solid framework for manipulation. While a series of transform
      manipulators are provided, you can build your own manipulators. This document includes a
        <span class="bold"><strong>Tutorial for building a custom manipulator</strong></span>.</p><p>Manipulation in the SceneGraph works by modifying the dependency graph's data in
      JavaScript. For this, several steps of execution are required:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>On MouseDown: Gather all of the current relevant values (snapshot) and attach event
            callbacks for MouseMove</p></li><li class="listitem"><p>On MouseMove: Compare current values with the snapshot and change the graph
            accordingly</p></li><li class="listitem"><p>On MouseUp: Remove the MouseMove event callbacks.</p></li></ol></div><div class="section" title="Setting up a Manipulator"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e542"></a>Setting up a Manipulator</h2></div></div></div><p>Manipulators require <span class="bold"><strong>RayCasting</strong></span> to be enable in the
        viewport, since it needs to determine which objects are hit below the mouse's position. To
        enable RayCasting, provide the following options when constructing the viewport:</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> viewport = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Viewport'</span>, {
  windowElement: document.getElementById(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'FabricContainer'</span>),
  enableRaycasting: true,
  rayIntersectionThreshold: <span class="hl-number">0.8</span>
});</pre><p>Manipulators operate on Instance nodes, so you first have to create an instance node to
        be able to attach a manipulator. Manipulators can operate on any member on any dependency
        graph node, but since typically manipulation in 3D affects the transforms of objects, all of
        the provided manipulators in the SceneGraph operate on the <span class="bold"><strong>globalXfo</strong></span> member of the transform node.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create an instance out of geometry, transform and material</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> instance = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Instance'</span>, {
  geometryNode: myGeometry,
  transformNode: myTransform,
  materialNode: myMaterial
});

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create a manipulator for the instance node</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> manipulator = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'3AxisTranslationManipulator'</span>, {
  targetNode: instance,
  size: <span class="hl-number">10</span>,
  linearTranslationManipulators: true,
  planarTranslationManipulators: true,
  screenTranslationManipulators: true
});</pre><p>For a list of all of the manipulators available and their options please refer to the
          <span class="bold"><strong>SceneGraph Node Reference</strong></span> in this document.</p><p><span class="italic">Note: The Manipulators.html sample application contains an
          example of how to use manipulation in the SceneGraph.</span></p></div></div><div class="chapter" title="Chapter&nbsp;15.&nbsp;Undo / Redo Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e554"></a>Chapter&nbsp;15.&nbsp;Undo / Redo Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e568">Using Undo and Redo with Manipulation</a></span></dt></dl></div><p>Undo and Redo functionality in the SceneGraph can be achieved by constructing the
        <span class="bold"><strong>UndoManager</strong></span> and pushing <span class="bold"><strong>Transactions</strong></span> to it. A transaction is a dictionary containing callbacks for
        <span class="bold"><strong>onClose</strong></span>, <span class="bold"><strong>onUndo</strong></span> and
        <span class="bold"><strong>onRedo</strong></span>. The SceneGraph's manipulation system provides these
      kinds of transactions already, but you can implement your own.</p><p>To undo or redo a transaction, simply call the on the <span class="bold"><strong>undo</strong></span> and <span class="bold"><strong>redo</strong></span> methods of the  of the
      UndoManager.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create an undo manager</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> undoMgr = scene.constructManager(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'UndoManager'</span>);

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create a value to be changed</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> value = <span class="hl-number">10</span>;
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> prevValue = value;
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> newValue;

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// push a transaction to it</span>
undoMgr.addTransaction({
  onClose: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>() {
    newValue = value;
  },
  onUndo: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>() {
    value = prevValue;
  },
  onRedo: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>() {
    value = newValue;
  }
});

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// change the value</span>
value = <span class="hl-number">20</span>;

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// close the transaction</span>
undoMgr.closeTransaction();

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// undo the change</span>
undoMgr.undo();</pre><p><span class="italic">Note: The Undo.html sample application contains an example of how
        to use Undo and Redo in the SceneGraph.</span></p><div class="section" title="Using Undo and Redo with Manipulation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e568"></a>Using Undo and Redo with Manipulation</h2></div></div></div><p>The manipulation system already supports undo. Since you can have multiple UndoManagers
        in an application, you can optionally provide the UndoManager to the construction options of
        the manipulators, but even if you didn't specify it the first created undomanager will be
        used for manipulation.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create an undo manager</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> undoMgr = scene.constructManager(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'UndoManager'</span>);

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create a manipulator for the instance node</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> manipulator = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'3AxisTranslationManipulator'</span>, {
  targetNode: instance,
  size: <span class="hl-number">10</span>,
  linearTranslationManipulators: true,
  planarTranslationManipulators: true,
  screenTranslationManipulators: true,
  undoManager: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">undefined</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// optionally you can specify it here, in case you have more than one</span>
});</pre></div></div><div class="chapter" title="Chapter&nbsp;16.&nbsp;Websockets Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e572"></a>Chapter&nbsp;16.&nbsp;Websockets Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e578">WebSocketManager</a></span></dt><dt><span class="section"><a href="#d5e589">Sending Messages</a></span></dt><dt><span class="section"><a href="#d5e594">Receiving Messages</a></span></dt></dl></div><p>The SceneGraph provides an easy way of using websockets to automate client - server -
      client communication. For this a node websocket server is required. For a sample
      implementation, please see our github project
        <code class="uri">http://github.com/fabric-engine/websocket-server</code>.</p><p>For test scenarios you might as well use node websocket server located at
        <code class="uri">ws.fabric-engine.com</code>.</p><div class="section" title="WebSocketManager"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e578"></a>WebSocketManager</h2></div></div></div><p>Before you can send or receive messages you need to setup the <span class="bold"><strong>WebSocketManager</strong></span>. Each session uses a unique key, which is determined
        automatically, however you can specify it yourself to ensure that all users of the
        application are able to communicate with each other. </p><p><span class="inlinemediaobject"><img src="images/JSSceneGraph/sg_websockets_01.png"></span></p><p>Since the web socket connection has to be established before message handlers can be
        setup, the constructor also takes in the <span class="bold"><strong>onOpenCallBack</strong></span>
        option, which is executed once the connection is up.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create a web socket manager</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> websocketMgr = scene.constructManager(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'WebSocketManager'</span>, {
  serverUrl: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'ws.fabric-engine.com'</span>,
  contextID: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myOwnCustomKey'</span>,
  onOpenCallBack: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>() {
    console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Connection established'</span>);
  }
});</pre></div><div class="section" title="Sending Messages"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e589"></a>Sending Messages</h2></div></div></div><p>To send message, ensure that the connection has been established. Otherwise the sending
        of the message will fail. Messages contain a name, data as well as an optional recipient. If
        you don't specify the recipient the message will be send to all of the participants of the
        current session.</p><pre class="programlisting">websocketMgr.sendMessage(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'askQuestion'</span>, { question: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'What\'s your name?'</span> });</pre><p>The data can contain any JSON compliant struct. The WebSocketManager encodes it and
        decodes it automatically.</p></div><div class="section" title="Receiving Messages"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e594"></a>Receiving Messages</h2></div></div></div><p>To receive messages you need to setup callbacks for each message type on the
        WebSocketManager. Reception message callbacks themselves can also send messages again of
        course.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// setup a message callback for the 'askQuestion' message</span>
websocketMgr.addMessageCallBack(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'askQuestion'</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>(message) {
  <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">if</span>(message.data.question == <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'What\'s your name?'</span>) {
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// reply just to the sender of this message</span>
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> data = {
      question: message.data.question,
      answer: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'My name is Fabric.'</span>
    };
    websocketMgr.sendMessage(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'replyToQuestion'</span>, data, message.sourceID);
  } <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">else</span>
    console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'I don\'t know how to answer this question: '</span>+message.data.question);
});

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// setup a message callback for the 'replyToQuestion' message</span>
websocketMgr.addMessageCallBack(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'replyToQuestion'</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span>(message) {
  console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'I asked: '</span>+message.data.question);
  console.log(message.sourceID+<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">' replied: '</span>+message.data.answer);
});</pre><p><span class="italic">Note: The WebSockets.html sample application demonstrates how to
          synchronize camera manipulation between clients.</span></p></div></div><div class="chapter" title="Chapter&nbsp;17.&nbsp;Bullet Physics Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d5e600"></a>Chapter&nbsp;17.&nbsp;Bullet Physics Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e606">Creating the Bullet world</a></span></dt><dt><span class="section"><a href="#d5e611">Creating Collision Shapes</a></span></dt><dt><span class="section"><a href="#d5e617">Creating Rigid Bodies</a></span></dt><dt><span class="section"><a href="#d5e627">Creating Soft Bodies</a></span></dt><dt><span class="section"><a href="#d5e632">Creating Constraints</a></span></dt><dt><span class="section"><a href="#d5e644">Creating Anchors</a></span></dt><dt><span class="section"><a href="#d5e648">Array functionality</a></span></dt></dl></div><p>The Fabric Engine SceneGraph contains a reference implementation of the Bullet Physics
      simulation engine (<code class="uri">http://www.bulletphysics.org</code>). It allows to create several
      different shapes, rigid bodies, soft bodies as well as constraints between them.</p><p>Bullet requires custom shapes to be constructed for collision. They can be different from
      the ones you see in the viewport, so for example you could create a box shape for a complex
      mesh based on its bounding box for a faster simulation.</p><p>Bullet operates on the SceneGraph's transform nodes.</p><div class="section" title="Creating the Bullet world"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e606"></a>Creating the Bullet world</h2></div></div></div><p>Each simulation requires a world to run in. You may create several worlds, but only
        object within the same world will effect each other.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> world = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BulletWorldNode'</span>);</pre><p>Once the world is set up you can start creating shapes and simulation elements.</p></div><div class="section" title="Creating Collision Shapes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e611"></a>Creating Collision Shapes</h2></div></div></div><p>The SceneGraph's Bullet implementation supports several basic shapes. Shapes are
        identified by their name. The name has to be unique, using the same name several times will
        result in an error. You can later use the shapes' names to construct rigid bodies. These are
        the basic shapes you can construct:</p><pre class="programlisting">world.addShape(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myBox'</span>, FABRIC.RT.BulletShape.createBox(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">1.0</span>,<span class="hl-number">1.0</span>,<span class="hl-number">1.0</span>)));
world.addShape(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'mySphere'</span>, FABRIC.RT.BulletShape.createBox(<span class="hl-number">1.0</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">/* radius */</span>));
world.addShape(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myCylinder'</span>, FABRIC.RT.BulletShape.createBox(<span class="hl-number">1.0</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">/* radius */</span>, <span class="hl-number">1.0</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">/* height */</span>));
world.addPlane(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myPlane'</span>, FABRIC.RT.BulletShape.createBox(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">0.0</span>,<span class="hl-number">1.0</span>,<span class="hl-number">0.0</span>)));</pre><p>Aside from the standard shapes you can also construct complex shapes based on SceneGraph
        geometry nodes. So for example, given the torus triangles node, you can construct either a
        convex hull collision shape or a triangle mesh, or a GImpact shape. Convex hull shapes are
        very fast and robust, but they don't provide actual shape collision. triangle mesh shapes
        are very slow for moving objects, and should be used only for complex ground shapes. GImpact
        shapes provide accurate collision for moving objects which need to support actual shape
        collision (inclusing concave shapes).</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> torus = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Torus'</span>); <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// this is a triangles node</span>
world.addShape(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myConvexHull'</span>,FABRIC.RT.BulletShape.createConvexHull(torus));
world.addShape(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myTriangleMesh'</span>,FABRIC.RT.BulletShape.createTriangleMesh(torus));
world.addShape(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myGImpact'</span>,FABRIC.RT.BulletShape.createGImpact(torus));</pre></div><div class="section" title="Creating Rigid Bodies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e617"></a>Creating Rigid Bodies</h2></div></div></div><p>Once you have constructed the shapes, you can create rigid bodies in the world. Rigid
        bodies have several settings, but the main important option is the <span class="bold"><strong>mass</strong></span>. If you set the mass to 0.0, the rigid body will be passive. This means
        Fabric Engine will continue to drive the transform of the rigid body, and it will affect the
        Bullet world. If the mass is set to &gt; 0.0 the rigid body is active, and is purely affected
        by the Bullet simulation.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// construct a passive plane</span>
world.addRigidBody(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'ground'</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.BulletRigidBody({
  mass: <span class="hl-number">0.0</span>
}), <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myPlane'</span>);

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// construct a passive plane</span>
world.addRigidBody(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'torusRbd1'</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.BulletRigidBody({
  mass <span class="hl-number">1.0</span>,
  friction: <span class="hl-number">0.6</span>,
  restitution: <span class="hl-number">0.2</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// bouncyness</span>
  transform: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Xfo({
    tr: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">0.0</span>,<span class="hl-number">4.0</span>,<span class="hl-number">0.0</span>)
  })
}), <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myConvexHull'</span>);
</pre><p>Note that we didn't connect up the rigid bodies to any element in the SceneGraph yet.
        Right now these objects are purely part of the world and are not visibile to the viewport at
        all. To create a transform that is connected to the Bullet world, you can construct a
          <span class="bold"><strong>BulletRigidBodyTransform</strong></span> node. The code below will setup
        a torus which is moving and visible in the viewport.</p><p>Once you have constructed the shapes, you can create rigid bodies in the world. Rigid
        bodies have several settings, but the main important option is the <span class="bold"><strong>mass</strong></span>. If you set the mass to 0.0, the rigid body will be passive. This means
        Fabric Engine will continue to drive the transform of the rigid body, and it will affect the
        Bullet world. If the mass is set to &gt; 0.0 the rigid body is active, and is purely affected
        by the Bullet simulation. Also note that you can create multiple rigid bodies using the same
        collision shape.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create a transform node driven by bullet</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> bulletTransform = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'BulletRigidBodyTransform'</span>, {
  name: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'torusRbd2'</span>,
  bulletWorldNode: world,
  shapeName: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myConvexHull'</span>,
  rigidBody: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.BulletRigidBody({
    transform: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Xfo({
      tr: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">0.0</span>,<span class="hl-number">4.0</span>,<span class="hl-number">0.0</span>)
    })
  })
});

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create an instance to draw the torus</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> instance = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Instance'</span>, {
  transformNode: bulletTransform,
  geometryNode: torus,
  materialNode: scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'PhongMaterial'</span>)
});</pre></div><div class="section" title="Creating Soft Bodies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e627"></a>Creating Soft Bodies</h2></div></div></div><p>While Rigid Bodies represent hard surfaces, Bullet also supports deforming surfaces,
        called <span class="bold"><strong>Soft Bodies</strong></span>. These bodies contain the shape as well,
        so they don't require a collision shape name for construction. Soft bodies don't use a
        transform, they are applied as a deformation on top of the geometry node.</p><pre class="programlisting"><span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create a softbody</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> torusSoftBody = world.addSoftBody(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'torusSbd1'</span>,<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.BulletSoftBody({
  trianglesNode: torus,
  transform: FABRIC.RT.xfo({
    tr: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">0</span>,<span class="hl-number">16</span>,<span class="hl-number">0</span>)
  }),
  stiffness: <span class="hl-number">0.1</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// spring stiffness</span>
  friction: <span class="hl-number">0.5</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// dynamic friction</span>
  conservation: <span class="hl-number">0.0</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// volume conservation</span>
  recover: <span class="hl-number">0.01</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// recover original shape per frame</span>
  pressure: <span class="hl-number">5</span>    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// internal pressure</span>
}));

<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// create an instance to draw the deforming</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// torus. no transform specified since the </span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment">// transform is included in the deformation</span>
<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> instance = scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Instance'</span>, {
  geometryNode: torusSoftBody,
  materialNode: scene.constructNode(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'PhongMaterial'</span>)
});</pre></div><div class="section" title="Creating Constraints"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e632"></a>Creating Constraints</h2></div></div></div><p>Constraints are connections between rigid bodies. The SceneGraph supports three types of constraints:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Point2Point: A ball and socket connection with 360 degrees of freedom</p></li><li class="listitem"><p>Hinge: A single axis rotation connection with 360 degrees of freedom</p></li><li class="listitem"><p>Slider: A single axis translation connection with 0 degrees of freedom</p></li></ul></div><p>For creating a constraint you need to specify the names of the two bodies to be
        connected as well as the constraint's options.</p><pre class="programlisting">world.addConstraint(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myBallSocket'</span>,FABRIC.RT.BulletConstraint.createPoint2Point({
  pivotA: FABRIC.RT.xfo({tr: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">0</span>,<span class="hl-number">4.0</span>,<span class="hl-number">0</span>)}),
  pivotB: FABRIC.RT.xfo({tr: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">0</span>,-<span class="hl-number">4.0</span>,<span class="hl-number">0</span>)}),
}),<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'torusRbd1'</span>,<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'torusRbd2'</span>);

world.addConstraint(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myHinge'</span>,FABRIC.RT.BulletConstraint.createHinge({
  pivotA: FABRIC.RT.xfo({tr: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">0</span>,<span class="hl-number">4.0</span>,<span class="hl-number">0</span>)}),
  pivotB: FABRIC.RT.xfo({tr: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">0</span>,-<span class="hl-number">4.0</span>,<span class="hl-number">0</span>)}),
}),<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'torusRbd1'</span>,<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'torusRbd2'</span>);

world.addConstraint(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'mySlider'</span>,FABRIC.RT.BulletConstraint.createSlider({
  pivotA: FABRIC.RT.xfo({tr: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">0</span>,<span class="hl-number">4.0</span>,<span class="hl-number">0</span>)}),
  pivotB: FABRIC.RT.xfo({tr: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.Vec3(<span class="hl-number">0</span>,-<span class="hl-number">4.0</span>,<span class="hl-number">0</span>)}),
}),<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'torusRbd1'</span>,<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'torusRbd2'</span>);</pre></div><div class="section" title="Creating Anchors"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e644"></a>Creating Anchors</h2></div></div></div><p>Anchors are connections between rigid bodies and soft bodies. Aside from the names of
        the rigid body and the soft body it is also required to specify an array of point indices on
        the softbody to attach the anchor to.</p><pre class="programlisting">world.addAnchor(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'myAnchor'</span>,<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">new</span> FABRIC.RT.BulletAnchor({
  softBodyNodeIndices: [<span class="hl-number">0</span>,<span class="hl-number">1</span>,<span class="hl-number">2</span>,<span class="hl-number">3</span>,<span class="hl-number">4</span>,<span class="hl-number">5</span>]
  }),<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'torusRbd1'</span>,<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'torusSbd1'</span>
);</pre></div><div class="section" title="Array functionality"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e648"></a>Array functionality</h2></div></div></div><p>All <span class="bold"><strong>add</strong></span> methods on the BulletWorldNode support single
        obbjects as well as arrays. This means that you can construct multiple rigid bodies at the
        same time, by providing an array of bodies rather than just a single one. This also works
        for constraints. For further details, please have a look at the <span class="italic">Constraints.html</span> or <span class="italic">StackingBoxes.html</span>
        sample applications.</p></div></div><div class="chapter" title="Chapter&nbsp;18.&nbsp;SceneGraphNode Reference"><div class="titlepage"><div><div><h2 class="title"><a name="d5e654"></a>Chapter&nbsp;18.&nbsp;SceneGraphNode Reference</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e657">SceneGraph.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e659">SceneGraphNode</a></span></dt><dt><span class="section"><a href="#d5e696">ResourceLoad</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e729">Geometry.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e731">Geometry</a></span></dt><dt><span class="section"><a href="#d5e785">GeometryDataCopy</a></span></dt><dt><span class="section"><a href="#d5e808">Points</a></span></dt><dt><span class="section"><a href="#d5e813">Lines</a></span></dt><dt><span class="section"><a href="#d5e818">LineStrip</a></span></dt><dt><span class="section"><a href="#d5e823">Triangles</a></span></dt><dt><span class="section"><a href="#d5e828">Instance</a></span></dt><dt><span class="section"><a href="#d5e887">LayerManager</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e901">Primitives.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e904">LineVector</a></span></dt><dt><span class="section"><a href="#d5e921">Cross</a></span></dt><dt><span class="section"><a href="#d5e944">Axis</a></span></dt><dt><span class="section"><a href="#d5e967">Rectangle</a></span></dt><dt><span class="section"><a href="#d5e996">BoundingBox</a></span></dt><dt><span class="section"><a href="#d5e1025">Grid</a></span></dt><dt><span class="section"><a href="#d5e1054">CameraPrimitive</a></span></dt><dt><span class="section"><a href="#d5e1077">Circle</a></span></dt><dt><span class="section"><a href="#d5e1112">Plane</a></span></dt><dt><span class="section"><a href="#d5e1153">Cuboid</a></span></dt><dt><span class="section"><a href="#d5e1209">Sphere</a></span></dt><dt><span class="section"><a href="#d5e1238">Torus</a></span></dt><dt><span class="section"><a href="#d5e1273">Cone</a></span></dt><dt><span class="section"><a href="#d5e1308">Cylinder</a></span></dt><dt><span class="section"><a href="#d5e1355">Teapot</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1384">Cameras.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1386">Camera</a></span></dt><dt><span class="section"><a href="#d5e1442">FreeCamera</a></span></dt><dt><span class="section"><a href="#d5e1459">TargetCamera</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1464">Images.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1467">Image</a></span></dt><dt><span class="section"><a href="#d5e1472">RenderTargetBufferTexture</a></span></dt><dt><span class="section"><a href="#d5e1486">Image2D</a></span></dt><dt><span class="section"><a href="#d5e1545">Image3D</a></span></dt><dt><span class="section"><a href="#d5e1610">CubeMap</a></span></dt><dt><span class="section"><a href="#d5e1624">Video</a></span></dt><dt><span class="section"><a href="#d5e1650">ScreenGrab</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1664">Materials.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1667">Shaders vs Materials</a></span></dt><dt><span class="section"><a href="#d5e1671">getShaderParamID</a></span></dt><dt><span class="section"><a href="#d5e1674">Shader</a></span></dt><dt><span class="section"><a href="#d5e1679">Material</a></span></dt><dt><span class="section"><a href="#d5e1752">ShadowMapMaterial</a></span></dt><dt><span class="section"><a href="#d5e1757">PointMaterial</a></span></dt><dt><span class="section"><a href="#d5e1783">LineMaterial</a></span></dt><dt><span class="section"><a href="#d5e1809">TransparentMaterial</a></span></dt><dt><span class="section"><a href="#d5e1814">InstancingMaterial</a></span></dt><dt><span class="section"><a href="#d5e1819">PostProcessEffect</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1824">Animation.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1826">AnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e1852">TrackAnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e1893">CharacterAnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e1973">LinearTrackAnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e1978">LinearCharacterAnimationContainer</a></span></dt><dt><span class="section"><a href="#d5e1983">BezierTrackAnimationContainer</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e1988">Persistence.js</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e1990">SceneSerializer</a></span></dt><dt><span class="section"><a href="#d5e2022">SceneDeserializer</a></span></dt><dt><span class="section"><a href="#d5e2057">LogWriter</a></span></dt><dt><span class="section"><a href="#d5e2060">LocalStorage</a></span></dt><dt><span class="section"><a href="#d5e2063">FileWriter</a></span></dt><dt><span class="section"><a href="#d5e2066">FileWriterWithBinary</a></span></dt><dt><span class="section"><a href="#d5e2069">FileReader</a></span></dt><dt><span class="section"><a href="#d5e2072">XHRReader</a></span></dt></dl></dd></dl></div><p>In this section you can find documentation for all of the current SceneGraphNodes provided
      by the JavaScript SceneGraph. For each node a short description is provided, as well as a
      reference to its options. Only the methods on the public interface are documented here. For
      further information on the private interfaces please refer to the JavaScript file providing
      the respective nodes.</p><div class="section" title="SceneGraph.js"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e657"></a>SceneGraph.js</h2></div></div></div><div class="section" title="SceneGraphNode"><div class="titlepage"><div><div><h3 class="title"><a name="d5e659"></a>SceneGraphNode</h3></div></div></div><p>ParentNode: <span class="bold"><strong>None</strong></span></p><p>This is the base node for all nodes in the SceneGraph. It is never constructed
          directly, but all other nodes use it as their base. The SceneGraphNode is responsible for
          constructing the dependency graph nodes and eventhandler nodes in the core, as well as
          deploying all of the base features provided by the SceneGraph, such as eventhandling
          etc.</p><p>Event related functions are only available on certain instances of the SceneGraphNode.
          This depends on the construction and if <span class="bold"><strong>addEventHandlingFunctions</strong></span> was called.</p><div class="table"><a name="d5e666"></a><p class="title"><b>Table&nbsp;18.1.&nbsp;SceneGraphNode Options</b></p><div class="table-contents"><table summary="SceneGraphNode Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>name</td><td>The name of the SceneGraph node. If not specified, it will default to its
                  type.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e675"></a><p class="title"><b>Table&nbsp;18.2.&nbsp;SceneGraphNode Methods</b></p><div class="table-contents"><table summary="SceneGraphNode Methods" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getName()</td><td>Returns the name of the node.</td></tr><tr><td>setName(name)</td><td>Sets the new name of the node.</td></tr><tr><td>addEventListener(event, func)</td><td>Adds a new function to the given event name.</td></tr><tr><td>removeEventListener(event,func)</td><td>Removes a function from listening to a given event name.</td></tr><tr><td>fireEvent(event)</td><td>Executes all of the listening functions of a given event name.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="ResourceLoad"><div class="titlepage"><div><div><h3 class="title"><a name="d5e696"></a>ResourceLoad</h3></div></div></div><p>ParentNode: <span class="bold"><strong>SceneGraphNode</strong></span></p><p>This node is used for loading external resources into Fabric Engine. Resources can be
          images, 3D files or any external binary content. The node supports loading the data to
          memory or storing it to a temporary file (default). The node also fires an <span class="italic">loadSuccess</span> event once the load is finished, so event listener
          can be attached accordingly.</p><div class="table"><a name="d5e702"></a><p class="title"><b>Table&nbsp;18.3.&nbsp;ResourceLoad Options</b></p><div class="table-contents"><table summary="ResourceLoad Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>url</td><td>The url of the external data resource</td></tr><tr><td>storeDataAsFile</td><td>If true the data is stored to a temporary file, otherwise the content is
                  stored in memory.</td></tr><tr><td>redrawOnLoad</td><td>If true the viewport will be refreshed automatically once loading is
                  finished.</td></tr><tr><td>blockRedrawingTillResourceIsLoaded</td><td>If true the viewport will not refresh during the load of the
                  resource.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e720"></a><p class="title"><b>Table&nbsp;18.4.&nbsp;ResourceLoad Methods</b></p><div class="table-contents"><table summary="ResourceLoad Methods" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>setUrl(url, force)</td><td>Sets the new URL for the resource. If force is true the node is force to
                  evaluate immediately.</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="Geometry.js"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e729"></a>Geometry.js</h2></div></div></div><div class="section" title="Geometry"><div class="titlepage"><div><div><h3 class="title"><a name="d5e731"></a>Geometry</h3></div></div></div><p>ParentNode: <span class="bold"><strong>SceneGraphNode</strong></span></p><p>The Geometry node is a base abstract node for all geometry nodes. The Geometry node
          provides basic OpenGL Vertex Buffer Object (VBO) management and other services common to
          all type of geometry. The Geometry node provides a uniformsDependency Graph node which is
          used to contain non-vertex data for the geometry. Non vertex data might be paramters used
          in a generator opator such as the radius of a sphere. The Geometry node also provides a
          Vertex Attribute Dependency Graph node. All per-vertex data is stored in the vertex dgnode
          as a sliced node. Each slice in the sliced node contains the vertex data for one vertex.
          This special vertex attribute node ensures that every vertex has the same attributes, and
          by simply adding a new data member, all verticies aquire the new data mamber. This model
          maps well to GPU memory layouts where all vertex attributes must have identical counts to
          evaluate efficiently. This model enables efficient multi-threaded operators to be applied
          to all vertices in a mesh. The trade-off is lightly higher memory usage, as shared vertex
          attributes are duplicated to each vertex.</p><p>Each of the derrived geometries must provide specialiazed drawing and raycasting
          operators to enable the derived geometry to inetgrate with the rendering and interaction
          systems of the Fabric Scene Graph. The combination of flexible vertex attributes sets, and
          custom draw operator makes it easy to define custom geometry types.</p><div class="table"><a name="d5e737"></a><p class="title"><b>Table&nbsp;18.5.&nbsp;Geometry Options</b></p><div class="table-contents"><table summary="Geometry Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>createBoundingBoxNode</td><td>Determines whether a bounding box node is constructed. </td></tr><tr><td>drawable</td><td>Determines whether the redraw event hander is set up and VBOs uploaded for
                  each vertex atribute. Note: drawing would not be required for a collision mesh for
                  example</td></tr><tr><td>dynamicIndices</td><td>Specifies whether the indices buffer should be dynamic. Geometry which has a
                  dynamcially chaning topoloy would set this to true. </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e752"></a><p class="title"><b>Table&nbsp;18.6.&nbsp;Geometry Methods</b></p><div class="table-contents"><table summary="Geometry Methods" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>addUniformValue()</td><td>Adds a new member to the uniforms Dependency Graph node.</td></tr><tr><td>addVertexAttributeValue(name, type, attributeoptions)</td><td>Adds a new vertex attribute to the geometry. The options object passed in can
                  specify ether the given vertex attribute should be used to generate a VBO using
                  the parameter genVBO: true. </td></tr><tr><td>reloadVBO(name)</td><td>Manually triggers an re-uploading of the vertex buffer to the GPU.</td></tr><tr><td>setAttributeDynamic(name)</td><td>Sets the given attribute to use Dynamic OpenGL buffers. Not this should be
                  called prior to the first time the geometry is drawn. </td></tr><tr><td>setAttributeStatic(name)</td><td>Sets the given attribute to use Static OpenGL buffers. Not this should be
                  called prior to the first time the geometry is drawn. </td></tr><tr><td>getVertexCount</td><td>Sets the number of vertices stored in the attributes node.</td></tr><tr><td>setVertexCount</td><td>Gets the number of vertices stored in the attributes node.</td></tr><tr><td>loadGeometryData</td><td>This method is used to load data into the geometry node. The Collada parser
                  uses this method to load parsed geometry data.s</td></tr><tr><td>getBoundingBox</td><td>Returns the corner coordinates of the bounding box for this node.s</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="GeometryDataCopy"><div class="titlepage"><div><div><h3 class="title"><a name="d5e785"></a>GeometryDataCopy</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Geometry</strong></span></p><p>The geometry data copy node provides a methd to create  geometries derived from a base
          geometry. Per-Point operators can be applied to the Geometry Data Copy, and these
          operators can reference the base geometry as an input. The GeometryDataCopy is a base type
          used to construct specialized deforming geometries. The GeometryDataCopy can be used to
          derive a new Point, Lines, or Triangle mesh as it only provides generic double buffering
          and operator evaluation of vertex attributes.</p><div class="table"><a name="d5e790"></a><p class="title"><b>Table&nbsp;18.7.&nbsp;GeometryDataCopy Options</b></p><div class="table-contents"><table summary="GeometryDataCopy Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>baseGeometryNode</td><td>The geometry to use as the base for this derived geometry.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e799"></a><p class="title"><b>Table&nbsp;18.8.&nbsp;GeometryDataCopy Methods</b></p><div class="table-contents"><table summary="GeometryDataCopy Methods" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>setBaseGeometry(geometry)</td><td>Sets the geometry to be used as base geometry.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Points"><div class="titlepage"><div><div><h3 class="title"><a name="d5e808"></a>Points</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Geometry</strong></span></p><p>The Points node creates a specialization of the gometry node for drawing point. It
          simply does this by adding a 'positions' vertex attribute, and providing drawing operators
          that issue the appropriate OpenGL draw comments during rendering.</p></div><div class="section" title="Lines"><div class="titlepage"><div><div><h3 class="title"><a name="d5e813"></a>Lines</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Geometry</strong></span></p><p>The Lines node creates a specialization of the gometry node for drawing lines. It
          simply does this by adding a 'positions' vertex attribute, and an indices Uniform value,
          and providing drawing operators that issue the appropriate OpenGL draw comments during
          rendering.</p></div><div class="section" title="LineStrip"><div class="titlepage"><div><div><h3 class="title"><a name="d5e818"></a>LineStrip</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Geometry</strong></span></p><p>The LineStrip node creates a specialization of the gometry node for drawing line
          strips. The only difference between Lines and LineStrip is the drawing operator provided
          assumes a GL_LINESTRIP layout of the vertex indices array.</p></div><div class="section" title="Triangles"><div class="titlepage"><div><div><h3 class="title"><a name="d5e823"></a>Triangles</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Geometry</strong></span></p><p>The Triangles node creates a specialization of the gometry node for drawing triangles.
          It does this by adding several vertex attrinbutes that are used in drawing triangles. The
          'positions' and 'normal' vertex attributes are provided, along with optional VU sets
          ('uvs0'), and tangents.</p></div><div class="section" title="Instance"><div class="titlepage"><div><div><h3 class="title"><a name="d5e828"></a>Instance</h3></div></div></div><p>ParentNode: <span class="bold"><strong>SceneGraphNode</strong></span></p><p>The Instance Scene Graph node represents a drawn geometry. The Instance node is used
          to bind a Geomerty to a Transform and a Material and draw the results on screen. When a
          geometry is assigned to an instance node, the Instance node requests the geometries 'draw
          operator', and assigns the draw operator to the instance's draw event handler. The
          Instance node also handles raycasting of geometries. When a material is assigned to an
          Instance, the instance connectes its draw event handler to the materials draw event
          handler. This ensures that when the matierl is set up for rendering, the draw event
          handler of the Instance is then invoked causing the drawing of the geometry.</p><div class="table"><a name="d5e833"></a><p class="title"><b>Table&nbsp;18.9.&nbsp;Instance Options</b></p><div class="table-contents"><table summary="Instance Options" border="0"><colgroup><col width="249" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>transformNode</td><td>The transform node to use to control the transform the geometry in the
                  scene.</td></tr><tr><td>transformNodeMember</td><td>TODO: remove me</td></tr><tr><td>transformNodeIndex</td><td>TODO: remove me</td></tr><tr><td>constructDefaultTransformNode</td><td>The Instance node will construct a default transform node if none is
                  provided. </td></tr><tr><td>geometryNode</td><td>The Geometry node that will be used in drawing/racasting</td></tr><tr><td>transformNode</td><td>The Transform node that will be used in drawing/raycasting.</td></tr><tr><td>materialNode</td><td>The Material node that will be used in drawing.</td></tr><tr><td>enableRaycasting</td><td>The option to enable/disable raycasting for this instance</td></tr><tr><td>enableDrawing</td><td>The option to enable/disable drawing for this instance</td></tr><tr><td>raycastOverlaid</td><td>In some cases, it is required that a given geometry returns raycast results
                  even if occlueded by other geometries. This is the case when a geometry is being
                  used as a Manipulator widget. The Manipulator widgets are drawn over the top of
                  all geometry, and must also respond to mouse events. This option causes the
                  Instance to alsways return a raycast result with a distance of 0. </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e869"></a><p class="title"><b>Table&nbsp;18.10.&nbsp;GeometryDataCopy Methods</b></p><div class="table-contents"><table summary="GeometryDataCopy Methods" border="0"><colgroup><col width="248" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getGeometryNode/setGeometryNode</td><td>Gets/Sets the Geometry node</td></tr><tr><td>getTransformNode/setTransformNode</td><td>Gets/Sets the Transform node</td></tr><tr><td>getMaterialNode/setMaterialNode</td><td>Gets/Sets the Material node</td></tr><tr><td>getLayerManagerNode/setLayerManagerNode</td><td>Gets/Sets the Layer Manager node. When an Instance is assigned to a layer in
                  a Layer Manager, it binds an operator to its dgnode that drives the draw toggle
                  from the value of the assigned layer in the layer manger. This means that if the
                  layer is disabled, all Instances assigned to that layer become disabled.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="LayerManager"><div class="titlepage"><div><div><h3 class="title"><a name="d5e887"></a>LayerManager</h3></div></div></div><p>ParentNode: <span class="bold"><strong></strong></span></p><p>The Layer Manager is a very simply Manager for contolling the drawing of many
          Instances at once. When an I</p><div class="table"><a name="d5e892"></a><p class="title"><b>Table&nbsp;18.11.&nbsp;LayerManager Methods</b></p><div class="table-contents"><table summary="LayerManager Methods" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>addLayer(geometry)</td><td>Adds a new Boolean value to the Layer Manger with the given name. Each
                  assigned layer generates getter and setter functions to toggle the state of the
                  drawing for that layer. </td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="Primitives.js"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e901"></a>Primitives.js</h2></div></div></div><p>The Primitives are generated geometries, using operators to procedurally generate the
        data of the geometry. They expose methods to access and modify the paramters used by the
        generator operators.</p><div class="section" title="LineVector"><div class="titlepage"><div><div><h3 class="title"><a name="d5e904"></a>LineVector</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Lines</strong></span></p><p>The LineVector node simply draws a static line between 2 predefined points.</p><div class="table"><a name="d5e909"></a><p class="title"><b>Table&nbsp;18.12.&nbsp;LineVector Options</b></p><div class="table-contents"><table summary="LineVector Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>from</td><td>The start point of the line in the coordinte space of the line.</td></tr><tr><td>to</td><td>The end point of the line in the coordinte space of the line.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Cross"><div class="titlepage"><div><div><h3 class="title"><a name="d5e921"></a>Cross</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Lines</strong></span></p><p>The Cross node uses an operator to control the size and position of the 6 points that
          make up the 3 orthogonal line segments that make up the cross. The cross is drawn as 3
          line degments aligned to the majior axes of the local coordinate frame.</p><div class="table"><a name="d5e926"></a><p class="title"><b>Table&nbsp;18.13.&nbsp;Cross Options</b></p><div class="table-contents"><table summary="Cross Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>size</td><td>The size of the generated cross.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e935"></a><p class="title"><b>Table&nbsp;18.14.&nbsp;Cross Methods</b></p><div class="table-contents"><table summary="Cross Methods" border="0"><colgroup><col width="251" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getSize/setSize</td><td>Accessor methods for the size of the cross</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Axis"><div class="titlepage"><div><div><h3 class="title"><a name="d5e944"></a>Axis</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Lines</strong></span></p><p>The Axis node uses an operator to draw a set of labeled coordinate system axis. The
          axes are labeled 'X', 'Y', and 'Z'</p><div class="table"><a name="d5e949"></a><p class="title"><b>Table&nbsp;18.15.&nbsp;Axis Options</b></p><div class="table-contents"><table summary="Axis Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>size</td><td>The size of the generated cross.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e958"></a><p class="title"><b>Table&nbsp;18.16.&nbsp;Axis Methods</b></p><div class="table-contents"><table summary="Axis Methods" border="0"><colgroup><col width="251" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getSize/setSize</td><td>Accessor methods for the size of the cross</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Rectangle"><div class="titlepage"><div><div><h3 class="title"><a name="d5e967"></a>Rectangle</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Lines</strong></span></p><p>The Rectangle primitive displays a rectangle aligned to the X/Z plane.</p><div class="table"><a name="d5e972"></a><p class="title"><b>Table&nbsp;18.17.&nbsp;Rectangle Options</b></p><div class="table-contents"><table summary="Rectangle Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>length</td><td>The length of the generated rectangle in the local X axis.</td></tr><tr><td>width</td><td>The width of the generated rectangle in the local Z axis.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e984"></a><p class="title"><b>Table&nbsp;18.18.&nbsp;Rectangle Methods</b></p><div class="table-contents"><table summary="Rectangle Methods" border="0"><colgroup><col width="252" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getLength/setLength</td><td>Accessor methods for the length of the rectangle primitive</td></tr><tr><td>getWidth/setWidth</td><td>Accessor methods for the width of the rectangle primitive</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="BoundingBox"><div class="titlepage"><div><div><h3 class="title"><a name="d5e996"></a>BoundingBox</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Lines</strong></span></p><p>The BoundingBox primitive displays a box using top left, and bottom right coordinates
          to control the size and offset of the box.</p><div class="table"><a name="d5e1001"></a><p class="title"><b>Table&nbsp;18.19.&nbsp;BoundingBox Options</b></p><div class="table-contents"><table summary="BoundingBox Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>bboxmin</td><td>The length of the generated rectangle in the local X axis.</td></tr><tr><td>bboxmax</td><td>The width of the generated rectangle in the local Z axis.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1013"></a><p class="title"><b>Table&nbsp;18.20.&nbsp;BoundingBox Methods</b></p><div class="table-contents"><table summary="BoundingBox Methods" border="0"><colgroup><col width="252" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getBoundingBoxMin/setBoundingBoxMin</td><td>Accessor methods for the min coordinates of the bounding box.</td></tr><tr><td>getBoundingBoxMax/setBoundingBoxMax</td><td>Accessor methods for the max coordinates of the bounding box.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Grid"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1025"></a>Grid</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Lines</strong></span></p><p>The Grid primitive displays a 3 dimensional grid</p><div class="table"><a name="d5e1030"></a><p class="title"><b>Table&nbsp;18.21.&nbsp;Grid Options</b></p><div class="table-contents"><table summary="Grid Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>size_x</td><td>The size of the grid in the X axis</td></tr><tr><td>size_y</td><td>The size of the grid in the Y axis</td></tr><tr><td>size_z</td><td>The size of the grid in the Z axis</td></tr><tr><td>sections_x</td><td>The number of sections of the grid along the X axis</td></tr><tr><td>sections_y</td><td>The number of sections of the grid along the Y axis</td></tr><tr><td>sections_z</td><td>The number of sections of the grid along the Z axis</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="CameraPrimitive"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1054"></a>CameraPrimitive</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Lines</strong></span></p><p>The CameraPrimitive is used to draw a Camera icon on screen. The camera primitive
          draws a box with a cone attached indicating the oriantation of the camera. This can be
          used to visualize cameras in the 3d viewport.</p><div class="table"><a name="d5e1059"></a><p class="title"><b>Table&nbsp;18.22.&nbsp;CameraPrimitive Options</b></p><div class="table-contents"><table summary="CameraPrimitive Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>size</td><td>The size of the generated cross.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1068"></a><p class="title"><b>Table&nbsp;18.23.&nbsp;CameraPrimitive Methods</b></p><div class="table-contents"><table summary="CameraPrimitive Methods" border="0"><colgroup><col width="251" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getSize/setSize</td><td>Accessor methods for the size of the drawn primitive</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Circle"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1077"></a>Circle</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Lines</strong></span></p><p>The Circle primitive can be used to draw either a circle, or an arc if a the arc ancle
          specified is less than 2pi.</p><div class="table"><a name="d5e1082"></a><p class="title"><b>Table&nbsp;18.24.&nbsp;CameraPrimitive Options</b></p><div class="table-contents"><table summary="CameraPrimitive Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>radius</td><td>The size of the generated cross.</td></tr><tr><td>arcAngle</td><td>the angle, specified in radians of the drawn Circle. By default the 'Circle'
                  draws a complete circle, however, an arc can be drawn by specifying a value less
                  than 2 pi.</td></tr><tr><td>numSegments</td><td>The number of line segments used to draw the circle/arc.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1097"></a><p class="title"><b>Table&nbsp;18.25.&nbsp;CameraPrimitive Methods</b></p><div class="table-contents"><table summary="CameraPrimitive Methods" border="0"><colgroup><col width="251" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getRadius/setRadius</td><td>Accessor methods for the radius of the drawn circle/arc</td></tr><tr><td>getArcAngle/setArcAngle</td><td>Accessor methods for the angle of the drawn circle/arc</td></tr><tr><td>getNumSegments/setNumSegments</td><td>Accessor methods for the number of line segments use when drawing the
                  arc/circle</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Plane"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1112"></a>Plane</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Triangles</strong></span></p><p>The Plane primitive draws </p><div class="table"><a name="d5e1117"></a><p class="title"><b>Table&nbsp;18.26.&nbsp;Plane Options</b></p><div class="table-contents"><table summary="Plane Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>length</td><td>The length of the plane in the X axis</td></tr><tr><td>width</td><td>The width of the plane in the Z axis</td></tr><tr><td>lengthSections</td><td>The number of length sections to use when building the plane.</td></tr><tr><td>widthSections</td><td>The number of width sections to use when building the plane</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1135"></a><p class="title"><b>Table&nbsp;18.27.&nbsp;Plane Methods</b></p><div class="table-contents"><table summary="Plane Methods" border="0"><colgroup><col width="251" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getLength/setLength</td><td>Accessor methods for the length of the drawn plane</td></tr><tr><td>getWidth/setWidth</td><td>Accessor methods for the width of the drawn plane</td></tr><tr><td>getLengthSections/setLengthSections</td><td>Accessor methods for the number of length sections to use when drawing the
                  plane.</td></tr><tr><td>getWidthSections/setWidthSections</td><td>Accessor methods for the number of width sections to use when drawing the
                  plane.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Cuboid"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1153"></a>Cuboid</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Triangles</strong></span></p><p>The Cuboid primitive draws a cuboid.</p><div class="table"><a name="d5e1158"></a><p class="title"><b>Table&nbsp;18.28.&nbsp;Cuboid Options</b></p><div class="table-contents"><table summary="Cuboid Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>length</td><td>The length of the cuboid in the X axis</td></tr><tr><td>width</td><td>The width of the cuboid in the Z axis</td></tr><tr><td>height</td><td>The height of the cuboid in the Y axis</td></tr><tr><td>lengthSections</td><td>The number of length sections to use when building the cuboid.</td></tr><tr><td>widthSections</td><td>The number of width sections to use when building the cuboid</td></tr><tr><td>heightSections</td><td>The number of height sections to use when building the cuboid</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1182"></a><p class="title"><b>Table&nbsp;18.29.&nbsp;Cuboid Methods</b></p><div class="table-contents"><table summary="Cuboid Methods" border="0"><colgroup><col width="251" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getLength/setLength</td><td>Accessor methods for the length of the drawn cuboid</td></tr><tr><td>getWidth/setWidth</td><td>Accessor methods for the width of the drawn cuboid</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>getLengthSections/setLengthSections</td><td>Accessor methods for the number of length sections to use when drawing the
                  cuboid.</td></tr><tr><td>getWidthSections/setWidthSections</td><td>Accessor methods for the number of width sections to use when drawing the
                  cuboid.</td></tr><tr><td>getHeightSections/setHeightSections</td><td>Accessor methods for the number of height sections to use when drawing the
                  cuboid</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Sphere"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1209"></a>Sphere</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Triangles</strong></span></p><p>The Sphere primitive draws a sphere on screen using triangles.</p><div class="table"><a name="d5e1214"></a><p class="title"><b>Table&nbsp;18.30.&nbsp;Sphere Options</b></p><div class="table-contents"><table summary="Sphere Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>radius</td><td>The radius of the sphere </td></tr><tr><td>detail</td><td>The detail parameter controls the number of length and width sections.
                </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1226"></a><p class="title"><b>Table&nbsp;18.31.&nbsp;Sphere Methods</b></p><div class="table-contents"><table summary="Sphere Methods" border="0"><colgroup><col width="251" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getRadius/setRadius</td><td>Accessor methods for the length of the sphere</td></tr><tr><td>getDetail/setDetail</td><td>Accessor methods for the width of the sphere</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Torus"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1238"></a>Torus</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Triangles</strong></span></p><p>The Torus primitive draws a torus on screen using triangles.</p><div class="table"><a name="d5e1243"></a><p class="title"><b>Table&nbsp;18.32.&nbsp;Torus Options</b></p><div class="table-contents"><table summary="Torus Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>innerRadius</td><td>The radius of the hole throught he middle of the torus </td></tr><tr><td>outerRadius</td><td>The radius of the body section of the torus</td></tr><tr><td>detail</td><td>The detail parameter controls the number of sections used to generate the
                  shape of the torus.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1258"></a><p class="title"><b>Table&nbsp;18.33.&nbsp;Torus Methods</b></p><div class="table-contents"><table summary="Torus Methods" border="0"><colgroup><col width="251" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getInnerRadius/setInnerRadius</td><td>Accessor methods for the length of the torus</td></tr><tr><td>getOuterRadius/setOuterRadius</td><td>Accessor methods for the outer radius of the torus</td></tr><tr><td>getDetail/setDetail</td><td>Accessor methods for the detail paramerer of the torus</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Cone"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1273"></a>Cone</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Triangles</strong></span></p><p>The Torus primitive draws a torus on screen using triangles.</p><div class="table"><a name="d5e1278"></a><p class="title"><b>Table&nbsp;18.34.&nbsp;Torus Options</b></p><div class="table-contents"><table summary="Torus Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>innerRadius</td><td>The radius of the hole throught he middle of the Cone </td></tr><tr><td>outerRadius</td><td>The radius of the body section of the Cone</td></tr><tr><td>detail</td><td>The detail parameter controls the number of sections used to generate the
                  shape of the Cone.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1293"></a><p class="title"><b>Table&nbsp;18.35.&nbsp;Torus Methods</b></p><div class="table-contents"><table summary="Torus Methods" border="0"><colgroup><col width="251" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getInnerRadius/setInnerRadius</td><td>Accessor methods for the length of the Cone</td></tr><tr><td>getOuterRadius/setOuterRadius</td><td>Accessor methods for the outer radius of the Cone</td></tr><tr><td>getDetail/setDetail</td><td>Accessor methods for the detail paramerer of the Cone</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Cylinder"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1308"></a>Cylinder</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Triangles</strong></span></p><p>The Cylinder primitive draws a cylinder on screen using triangles.</p><div class="table"><a name="d5e1313"></a><p class="title"><b>Table&nbsp;18.36.&nbsp;Cylinder Options</b></p><div class="table-contents"><table summary="Cylinder Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>radius</td><td>The radius of the body of the Cylinder </td></tr><tr><td>height</td><td>The height of the body of the Cylinder</td></tr><tr><td>caps</td><td>Constrols whether the generated cylinder is capped at both ends.</td></tr><tr><td>sides</td><td>The number of sides to use when generating the cylinder.</td></tr><tr><td>loops</td><td>the number of loops to use when generating the cylinder.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1334"></a><p class="title"><b>Table&nbsp;18.37.&nbsp;Cylinder Methods</b></p><div class="table-contents"><table summary="Cylinder Methods" border="0"><colgroup><col width="251" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getRadius/setRadius</td><td>Accessor methods for the radius of the Cylinder</td></tr><tr><td>getHeight/setHeight</td><td>Accessor methods for the height of the Cylinder</td></tr><tr><td>getCaps/setCaps</td><td>Accessor methods for the caps parameter of the Cylinder</td></tr><tr><td>getSides/setSides</td><td>Accessor methods for the number of sides of the Cylinder</td></tr><tr><td>getLoops/setLoops</td><td>Accessor methods for the number of loops of the Cylinder</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Teapot"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1355"></a>Teapot</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Triangles</strong></span></p><p>The Teapot primitive draws the classic teapot primitive onscreen using
          triangles.</p><div class="table"><a name="d5e1360"></a><p class="title"><b>Table&nbsp;18.38.&nbsp;Teapot Options</b></p><div class="table-contents"><table summary="Teapot Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>size</td><td>The size of the teapot primitive</td></tr><tr><td>detail</td><td>The detail parameter controls the number of sections used to generate the
                  shape of the Teapot.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1372"></a><p class="title"><b>Table&nbsp;18.39.&nbsp;Teapot Methods</b></p><div class="table-contents"><table summary="Teapot Methods" border="0"><colgroup><col width="251" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getSize/setSize</td><td>Accessor methods for the length of the Teapot</td></tr><tr><td>getDetail/setDetail</td><td>Accessor methods for the detail paramerer of the Teapot</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="Cameras.js"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e1384"></a>Cameras.js</h2></div></div></div><div class="section" title="Camera"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1386"></a>Camera</h3></div></div></div><p>ParentNode: <span class="bold"><strong>SceneGraphNode</strong></span></p><p>The base Camera node is used to control the viewpoint and projection used during
          rendering.</p><div class="table"><a name="d5e1391"></a><p class="title"><b>Table&nbsp;18.40.&nbsp;Camera Options</b></p><div class="table-contents"><table summary="Camera Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>nearDistance</td><td>The near clipping plane distance for the camera.</td></tr><tr><td>farDistance</td><td>The far clipping plane distance for the camera.</td></tr><tr><td>fovY</td><td>The vertical (Y) field of view angle for this camera. </td></tr><tr><td>focalDistance</td><td>The focal distance for the camera.</td></tr><tr><td>orthographic</td><td>Set to true the camera is rendered in orthographic more, otherwise
                  perspective mode is used.</td></tr><tr><td>transformNode</td><td>The transform node to use.</td></tr><tr><td>screenOffset</td><td>Viewport center offset</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1418"></a><p class="title"><b>Table&nbsp;18.41.&nbsp;Camera Methods</b></p><div class="table-contents"><table summary="Camera Methods" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getNearDistance/setNearDistance</td><td>Get/Set the near clipping plane distance.</td></tr><tr><td>getFarDistance/setFarDistance</td><td>Get/Set the far clipping plane distance.</td></tr><tr><td>getFovY/setFovY</td><td>Get/Set the vertical (Y) field of view angle. </td></tr><tr><td>getFocalDistance/setFocalDistance</td><td>Get/Set the focal distance. Note: the focal distance may be used in shaders
                  that perform lense effects. Also, the focal distance is computed in the
                  'TargetCamera' defined below.</td></tr><tr><td>getOrthographic/setOrthographic</td><td>Sets the given attribute to use Static OpenGL buffers. Not this should be
                  called prior to the first time the geometry is drawn. </td></tr><tr><td>getTransformNode/setTransformNode</td><td>Get/Set the Transform node used by this camera.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="FreeCamera"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1442"></a>FreeCamera</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Camera</strong></span></p><p>A free camera is transformed using a regular Transform node, rather than using a
          target position to align the camera. A free camera is usefull when setting up orthographic
          projections where you do not want the camera to alight ot any given target, but simpy
          maintain a given orientation. The Free camera exposes no extra methos, and simply
          configures a default transform node.</p><div class="table"><a name="d5e1447"></a><p class="title"><b>Table&nbsp;18.42.&nbsp;FreeCamera Options</b></p><div class="table-contents"><table summary="FreeCamera Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>position</td><td>The initial position of the camera.</td></tr><tr><td>orientation</td><td>the initial orientation of the camera.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="TargetCamera"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1459"></a>TargetCamera</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Camera</strong></span></p><p>The TargetCamera uses the 'AimTransform' node to align itself with a given target. The
          TargetCamera uses the distance from the camera to the target to compute its focalDistance.
          Most of the demos in the Fabric demos page use Target Camera as it it</p></div></div><div class="section" title="Images.js"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e1464"></a>Images.js</h2></div></div></div><p>The nodes defined in the Images file are all retating to the storage of pixel data,
        either from loaded images, or generated on the GPU.</p><div class="section" title="Image"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1467"></a>Image</h3></div></div></div><p>ParentNode: <span class="bold"><strong>SceneGraphNode</strong></span></p><p>The base Image provides no functionality and is simply a parent type for all image
          types.</p></div><div class="section" title="RenderTargetBufferTexture"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1472"></a>RenderTargetBufferTexture</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Image</strong></span></p><p>The RenderTargetBufferTexture is used to bind render target buffers to be used as
          textures. This Image type is used for planar reflections, where the scene is rendered to a
          buffer and then the buffer used as a texture on a reflective surface. It is also used in
          the Deffered Renderer to provide the buffered generated in the 'pre-pass' as textures to
          the 'post pass' shaders. </p><div class="table"><a name="d5e1477"></a><p class="title"><b>Table&nbsp;18.43.&nbsp;RenderTargetBufferTexture Options</b></p><div class="table-contents"><table summary="RenderTargetBufferTexture Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>bufferIndex</td><td>The index of the render target buffer to be bound as a texture. </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Image2D"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1486"></a>Image2D</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Image</strong></span></p><p>The Image2D node is the basic texture storage node. The Image2D node holds generic
          image data (members: pixels, width, height), which might be color or grayscale. If
          'options.createResourceLoadNode' is passed in as true, an URL-based image loader will be
          incorporated, and used to load the pixel data. The Image2D node currently supports RGB,
          RGBA 8 bits per pixel images, and Color 32 bits per pixel images, and Scalar pixel
          formats.</p><div class="table"><a name="d5e1491"></a><p class="title"><b>Table&nbsp;18.44.&nbsp;Image2D Options</b></p><div class="table-contents"><table summary="Image2D Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>format</td><td>Pixel format. Currently supported: RGB, RGBA, Color and Scalar.</td></tr><tr><td>createDgNodes</td><td>If this is set to true the Image node will construct a dgnode to store the
                  pixel data. The dgnode stores the data in multiple slices, one slice for each
                  pixel. This is usefull for when building applications that need to perform
                  per-pixel operations on the CPU. operators applied to the pixels dgnode operate in
                  a similar way to operators that operate on vertices of a geometry, being applied
                  to many pixels in parallel.</td></tr><tr><td>createResourceLoadNode</td><td>Set to true this flag will enable the Image node to load a texture off a
                  resource load node.</td></tr><tr><td>createLoadTextureEventHandler</td><td>If the image uses a ResouceLoadNode and this flag is set, it will create an
                  EventHandler for the Image being loaded.</td></tr><tr><td>width</td><td>The width of the empty Image</td></tr><tr><td>height</td><td>The height of the empty Image</td></tr><tr><td>color</td><td>When initializing an emply image, all the pixels are set to this
                  color</td></tr><tr><td>url</td><td>&nbsp;</td></tr><tr><td>forceRefresh</td><td>If this is set, the Image will always be re-loaded onto the GPU. This is
                  useful for animated Images.</td></tr><tr><td>glRepeat</td><td>If set to true, the image is set to repeat in bot U and V directions.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1527"></a><p class="title"><b>Table&nbsp;18.45.&nbsp;Image2D Methods</b></p><div class="table-contents"><table summary="Image2D Methods" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getWidth</td><td>Get the width of the stored texture. Note: this method is only available when
                  createDgNodes is set to true when constructing this node.</td></tr><tr><td>getHeight</td><td>Get the height of the stored texture. Note: this method is only available
                  when createDgNodes is set to true when constructing this node.</td></tr><tr><td>getResourceLoadNode</td><td>Get the resource load node used to load the image data.</td></tr><tr><td>isImageLoaded</td><td>Returns true once the image has finished loading.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Image3D"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1545"></a>Image3D</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Image</strong></span></p><p>The Image3D node holds generic image data (members: pixels, width, height, depth),
          which might be color or grayscale. If  'options.createResourceLoadNode' is passed in as
          true, an URL-based image loader will be incorporated, and used to load the pixel data. The
          Image3D node currently supports RGBA 8 bits per pixel images, and Color 32 bits per pixel
          images. The Image3D node is used in the volume rendering demos to store the volumetric MRI
          data.</p><div class="table"><a name="d5e1550"></a><p class="title"><b>Table&nbsp;18.46.&nbsp;Image2D Options</b></p><div class="table-contents"><table summary="Image2D Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>format</td><td>Pixel format. Currently supported: RGB, RGBA, Color and Scalar.</td></tr><tr><td>createDgNodes</td><td>If this is set to true the Image node will construct a dgnode to store the
                  pixel data. The dgnode stores the data in multiple slices, one slice for each
                  pixel. This is usefull for when building applications that need to perform
                  per-pixel operations on the CPU. operators applied to the pixels dgnode operate in
                  a similar way to operators that operate on vertices of a geometry, being applied
                  to many pixels in parallel.</td></tr><tr><td>createResourceLoadNode</td><td>Set to true this flag will enable the Image node to load a texture off a
                  resource load node.</td></tr><tr><td>createLoadTextureEventHandler</td><td>If the image uses a ResouceLoadNode and this flag is set, it will create an
                  EventHandler for the Image being loaded.</td></tr><tr><td>width</td><td>The width of the empty Image</td></tr><tr><td>height</td><td>The height of the empty Image</td></tr><tr><td>depth</td><td>The depth of the empty Image</td></tr><tr><td>url</td><td>&nbsp;</td></tr><tr><td>glRepeat</td><td>If set to true, the image is set to repeat in bot U and V directions.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1583"></a><p class="title"><b>Table&nbsp;18.47.&nbsp;Image2D Methods</b></p><div class="table-contents"><table summary="Image2D Methods" border="0"><colgroup><col width="249" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getWidth</td><td>Get the width of the stored texture. Note: this method is only available when
                  createDgNodes is set to true when constructing this node.</td></tr><tr><td>getHeight</td><td>Get the height of the stored texture. Note: this method is only available
                  when createDgNodes is set to true when constructing this node.</td></tr><tr><td>getDepth</td><td>Get the depth of the stored texture. Note: this method is only available when
                  createDgNodes is set to true when constructing this node.</td></tr><tr><td>getResourceLoadNode</td><td>Get the resource load node used to load the image data.</td></tr><tr><td>isImageLoaded</td><td>Returns true once the image has finished loading.</td></tr><tr><td>getUrl/setUrl</td><td>interface to the URL used to load the pixel data for this image.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="CubeMap"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1610"></a>CubeMap</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Image</strong></span></p><p>The CubeMap node contains 6 Image nodes which can be used to texture with cubic
          mapping. The 6 sides of the cube are loaed as separate textures. Note: the CubeMap only
          supports 8 bits per pixel textures at this point.</p><div class="table"><a name="d5e1615"></a><p class="title"><b>Table&nbsp;18.48.&nbsp;CubeMap Options</b></p><div class="table-contents"><table summary="CubeMap Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>urls</td><td>An array of six URLs to the six images to load.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="Video"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1624"></a>Video</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Image</strong></span></p><p>The CubeMap node contains 6 Image nodes which can be used to texture with cubic
          mapping. The 6 sides of the cube are loaed as separate textures. Note: the CubeMap only
          supports 8 bits per pixel textures at this point.</p><div class="table"><a name="d5e1629"></a><p class="title"><b>Table&nbsp;18.49.&nbsp;Video Options</b></p><div class="table-contents"><table summary="Video Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>url</td><td>The url of the video to load.</td></tr><tr><td>animationControllerNode</td><td>The animation controller used to drive the playback of the video</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1641"></a><p class="title"><b>Table&nbsp;18.50.&nbsp;Image2D Methods</b></p><div class="table-contents"><table summary="Image2D Methods" border="0"><colgroup><col width="249" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getAnimationController/setAnimationController</td><td>Get or set the Animation Controller. Animation Controllers are used to
                  calculate the time values to be used in the video node. The animation controller
                  can be used to calculate a looping time sequence for example.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="ScreenGrab"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1650"></a>ScreenGrab</h3></div></div></div><p>ParentNode: <span class="bold"><strong>SceneGraphNode</strong></span></p><p>The ScreenGrab node is used to capture the rendered openGL viewport to an image file. </p><div class="table"><a name="d5e1655"></a><p class="title"><b>Table&nbsp;18.51.&nbsp;Image2D Methods</b></p><div class="table-contents"><table summary="Image2D Methods" border="0"><colgroup><col width="249" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>saveAs</td><td>Used to open a saveAs dialog box and write out the image as a PNG
                  file.</td></tr></tbody></table></div></div><br class="table-break"></div></div><div class="section" title="Materials.js"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e1664"></a>Materials.js</h2></div></div></div><p>The materials system in Fabric is built using OpenGL shader based rendering using GLSL
        shaders. </p><div class="section" title="Shaders vs Materials"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1667"></a>Shaders vs Materials</h3></div></div></div><p>The rendering system in Fabric is built around the depth first traversial of the event
          hander graph atached to the window redraw event. The redraw event graph represents a
          callstack, where at each event handler, the children are visited in order and executed. A
          parent nodes is always evaluated before a child node, and a parent node can have many
          children. The 'Shader' node is the parent of the 'Material' nodes attached to it. The
          Shader node is responsible for loading the GLSL shader code into the GPU, and setting the
          shader context. The Material node is responsible for setting shader parameters, such as
          setting color values, or binding textures. </p><p>Changing the shader constex is a relatively expensive operation and should be
          minimized, and this is what drove the design of the rendering pipeline. For each shader,
          we load the shader and set the context, then for each Material, we set the parameters, and
          load appropriate textures. This graph structure enables batching of rendered objects
          acording to the Shader that they use, and also the Material parameters. This means that if
          you have many objects all drawn using the same shader and material parameters,they will be
          drawn together using only one shader binding. </p></div><div class="section" title="getShaderParamID"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1671"></a>getShaderParamID</h3></div></div></div><p>The getShaderParamID function is used to generate unique identifier IDs for shader
          attribute and uniform names. For example, a shader might have a uniform named 'positions'.
          At graph construciton time, we convert the string 'positions' into a number so that we can
          match shader uniforms with data in the graph without doing many string comparisons each
          frame. At the time the rendering system was being developed, KL did not provide strong
          support for strings, however this has changed, and so this techniqure may be removed in
          future. </p></div><div class="section" title="Shader"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1674"></a>Shader</h3></div></div></div><p>ParentNode: <span class="bold"><strong>SceneGraphNode</strong></span></p><p>The Shader node is used to load a GLSL shader onto the GPU. Shader nodes are never
          constructed directly, and instead are constructed by the Material. Each type of Material
          shares a common shader node. The Scene maintains a map of constructed Shader nodes,
          ensuring that only one of each type is constructed. This means that for a given Material
          type, such as 'FlatTextureMaterial', even if many different instances of the materil are
          constructed using different textures, only one shader node is constructed, and loaded
          during rendering.</p></div><div class="section" title="Material"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1679"></a>Material</h3></div></div></div><p>ParentNode: <span class="bold"><strong>SceneGraphNode</strong></span></p><p>The Material node is the base node used to construct all types of Materials. The
          Material node uses many passed in options to define the material interface. The material
          system is driven using XML files.</p><div class="section" title="Material XML File Structure"><div class="titlepage"><div><div><h4 class="title"><a name="d5e1684"></a>Material XML File Structure</h4></div></div></div><p>The Material node is the base node used to construct all types of Materials. The
            Material node uses many passed in options to define the material interface. The material
            system is driven using XML files.</p><p>The XML files define a mapping between GLSL shader code, and the naming
            conventions used in the SceneGraph. e.g. in your GLSL shader code you could use a
            variable called 'u_mvp', which contains your model view projeciton matix. In Fabric, the
            name this value is 'modelViewProjectionMatrix'. The XML file enables you to specify the
            mapping between your own variable names, and the naming convention used in Fabric. For
            variables that do not have a predefined meaning the the scenegraph, such as custom
            parameters for shaders, the XML file neables providing a user friendly name to be used
            to generate getters and setters for these paramers in JavaScript.</p><p>XML files containing shaders can be used to define custom material nodes using
            the helper function:</p><p><code class="code">FABRIC.SceneGraph.defineEffectFromFile('MaterialName',
              'MaterialXMLFile.XML);</code></p><p>The genrated node exposes and interface for assigning uniform values such as
            color and opacoity values, and also exposes an interface for assigning references such
            as textures and lights.</p><div class="section" title="name"><div class="titlepage"><div><div><h5 class="title"><a name="d5e1692"></a>name</h5></div></div></div><p>The name parameter is currently not used. </p></div><div class="section" title="prototypeMaterialType"><div class="titlepage"><div><div><h5 class="title"><a name="d5e1695"></a>prototypeMaterialType</h5></div></div></div><p>The prototypeMaterialType parameter enables the specification of a base material
              node to derive this custom material from. There are a collection of base material
              types that provide custom functionality that custom materials can inherit from.</p></div><div class="section" title="uniforms"><div class="titlepage"><div><div><h5 class="title"><a name="d5e1698"></a>uniforms</h5></div></div></div><p>The uniforms section defines the mapping between the uniforms used in the GLSL
              shader code, and the the interface exposed by the material. </p><div class="section" title="name"><div class="titlepage"><div><div><h6 class="title"><a name="d5e1701"></a>name</h6></div></div></div><p>The  name value specifies the name used int he GLSL code. This name value can be
                different for each  shader, and will often be shortened or abbreviated names used in
                the glsl code.</p></div><div class="section" title="constant"><div class="titlepage"><div><div><h6 class="title"><a name="d5e1704"></a>constant</h6></div></div></div><p>The constant value specifies the lable used in the SceneGraph. For example, if
                the constant name for the uniform 'u_materialColor' is specified as 'color', then a
                member called 'color' will be added to the material node, and a getter function
                called 'getColor', and a setter function called 'setColor' will be defined.</p></div><div class="section" title="type"><div class="titlepage"><div><div><h6 class="title"><a name="d5e1707"></a>type</h6></div></div></div><p>The type value specifies the Fabric registered type to use for this constant.
                All the GLSL types have corresponding Fabric types that are used when loading the
                uniform values. </p></div><div class="section" title="owner"><div class="titlepage"><div><div><h6 class="title"><a name="d5e1710"></a>owner</h6></div></div></div><p>The owner value is optional. The owner attribute specifies that the Material
                should not generate a member and getter and setter funcions, because this uniform is
                loaded by the specified node. For example, when the owner is listed as 'instance',
                the instance will load that uniform, and the material should not provide loading
                functions.</p></div></div><div class="section" title="attributes"><div class="titlepage"><div><div><h5 class="title"><a name="d5e1713"></a>attributes</h5></div></div></div><p>The attributes section defines the mapping between the attributes used in the GLSL
              shader code, and the vertex attributes stored in the geometry node. every shader uses
              the 'positions' attribute, but any custom vertex attributes can be listed, and if they
              exist on the geometry, they will be loaded prior to shader invocation.</p><div class="section" title="name"><div class="titlepage"><div><div><h6 class="title"><a name="d5e1716"></a>name</h6></div></div></div><p>The  name value specifies the name used in the GLSL code. This name value can be
                different for each  shader, and will often be shortened or abbreviated names used in
                the glsl code.</p></div><div class="section" title="binding"><div class="titlepage"><div><div><h6 class="title"><a name="d5e1719"></a>binding</h6></div></div></div><p>The binding value specifies the name of the member on the geometry's attribute
                node. For example, all triangles support 'positions', and 'normals' as attributes,
                but geometries can have any number of attributes assigned, and those attributes can
                be mapped to GLSL shader attributes using the binding value here.</p></div></div><div class="section" title="programParams"><div class="titlepage"><div><div><h5 class="title"><a name="d5e1722"></a>programParams</h5></div></div></div><p>The programParams sections enables the definition of custom GLSL program
              parameters. Any OpenGL program params can be listed, and can be used, for example, to
              control tesselation, or geometry shader parameters. An example of a shader that uses
              custom program params, is the 'NormalShader' that uses the OpenGL 'Geometry Shader' to
              convert vertex positions and normals to lines to enable drawing of normals on screen. </p><div class="section" title="name"><div class="titlepage"><div><div><h6 class="title"><a name="d5e1725"></a>name</h6></div></div></div><p>The  name value specifies the name of the OpenGL program param.</p></div><div class="section" title="value"><div class="titlepage"><div><div><h6 class="title"><a name="d5e1728"></a>value</h6></div></div></div><p>The value attribute specifies the value to set the specified OpenGL program
                param to.</p></div></div><div class="section" title="drawParams"><div class="titlepage"><div><div><h5 class="title"><a name="d5e1731"></a>drawParams</h5></div></div></div><p>The drawParams sections enables the definition of custom GLSL draw parameters that
              are to be set by the shader node. </p><div class="section" title="drawMode"><div class="titlepage"><div><div><h6 class="title"><a name="d5e1734"></a>drawMode</h6></div></div></div><p>The drawMode can be set to a custom draw method, instead of using the default fo
                the drawn geometry type.</p></div><div class="section" title="patchVertices"><div class="titlepage"><div><div><h6 class="title"><a name="d5e1737"></a>patchVertices</h6></div></div></div><p>The patchVertices value can be specified when using tesselation shaders to
                control how the patches are generated at the tesselation stage.</p></div></div><div class="section" title="Shader Sources"><div class="titlepage"><div><div><h5 class="title"><a name="d5e1740"></a>Shader Sources</h5></div></div></div><p>For a complete OpenGL shader to run, shader sources must be specified for each
              relevant shader stage. In the Shader sources of the XML file, source code can be
              specified for vertex, and fragment shaders, and also the more advanced shaders such as
              Geometry, and Tesselation shaders. </p><div class="section" title="include"><div class="titlepage"><div><div><h6 class="title"><a name="d5e1743"></a>include</h6></div></div></div><p>Each of the various shader sources can include extra files. These included files
                are simply inlined and evaluated as part of the entire shader source.</p></div><div class="section" title="vertexshader"><div class="titlepage"><div><div><h6 class="title"><a name="d5e1746"></a>vertexshader</h6></div></div></div><p>The vertex shader sectionb lists GLSL vertex shader code. </p></div><div class="section" title="fragmentshader"><div class="titlepage"><div><div><h6 class="title"><a name="d5e1749"></a>fragmentshader</h6></div></div></div><p>The fragment shader sectionb lists GLSL fragment, or pixel shader code. </p></div></div></div></div><div class="section" title="ShadowMapMaterial"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1752"></a>ShadowMapMaterial</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Material</strong></span></p><p>The ShadowMapMaterial is a base material type that enables materials that are used in
          shadow map rendering to be derived from. The ShadowMapMaterial integrates the material
          into the drawing pipline at the point where shadow maps are being rendered from the lights
          point of view. The </p></div><div class="section" title="PointMaterial"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1757"></a>PointMaterial</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Material</strong></span></p><p>The PointMaterial extends the base Material with parameters for controlling the size
          of drawn points using the FixedFunction OpenGL calls. By specifying the PointMaterial as
          the 'PrototypeMaterial' in the shader XML file, shaders can extend this material type with
          custom drawing code.</p><div class="table"><a name="d5e1762"></a><p class="title"><b>Table&nbsp;18.52.&nbsp;PointMaterial Options</b></p><div class="table-contents"><table summary="PointMaterial Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>pointSize</td><td>The default size value to be used to draw the points</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1771"></a><p class="title"><b>Table&nbsp;18.53.&nbsp;PointMaterial Methods</b></p><div class="table-contents"><table summary="PointMaterial Methods" border="0"><colgroup><col width="249" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getPointSize/setPointSize</td><td>Get and set the size values used to render the points.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="LineMaterial"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1783"></a>LineMaterial</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Material</strong></span></p><p>The LineMaterial extends the base Material with parameters for controlling the
          thickness of drawn lines using the FixedFunction OpenGL calls. By specifying the
          LineMaterial as the 'PrototypeMaterial' in the shader XML file, shaders can extend this
          material type with custom drawing code.</p><div class="table"><a name="d5e1788"></a><p class="title"><b>Table&nbsp;18.54.&nbsp;LineMaterial Options</b></p><div class="table-contents"><table summary="LineMaterial Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>lineWidth</td><td>The default thickness value to be used when drawing the lines</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1797"></a><p class="title"><b>Table&nbsp;18.55.&nbsp;LineMaterial Methods</b></p><div class="table-contents"><table summary="LineMaterial Methods" border="0"><colgroup><col width="249" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getPointSize/setPointSize</td><td>Get and set the size values used to render the points.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="TransparentMaterial"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1809"></a>TransparentMaterial</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Material</strong></span></p><p>The TransparentMaterial is a base material type that enables transparent materials to
          be integrated in the drawing pipeline. The TransparentMaterial integrates the material
          into the drawing pipline after all opaque materials have been drawn. </p></div><div class="section" title="InstancingMaterial"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1814"></a>InstancingMaterial</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Material</strong></span></p><p>The InstancingMaterial is a base material type that is used when drawing multiple
          instances of the same geometry. The InstancingMaterial sets the paramter on the shader
          program called numInstances. The InstancingMaterial is used in conjunction with
          TransformTexture. The Texture is used to load an array of model matricies, and the
          Materials tells the shader how many insances to draw.</p></div><div class="section" title="PostProcessEffect"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1819"></a>PostProcessEffect</h3></div></div></div><p>ParentNode: <span class="bold"><strong>Material</strong></span></p><p>The PostProcessEffect is a base material type for post processing effect Material
          nodes. The PostProcessEffect is attached to the Viewport, and is bound before any of the
          scenes geometry is rendered. The PostProcessEffect material sets up an Frame Buffer Object
          and binds it during rendering before rendering traverses to the geometries. On the post
          descend operator stack, it unbinds the FBO, and binds it as a texture for the shader. A
          full screen quad is then rendered using the shader. There are several example post
          processing effect shaders provided that show how the post processing effect integrates
          with the render pipeline.</p></div></div><div class="section" title="Animation.js"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e1824"></a>Animation.js</h2></div></div></div><div class="section" title="AnimationContainer"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1826"></a>AnimationContainer</h3></div></div></div><p>ParentNode: <span class="bold"><strong>SceneGraphNode</strong></span></p><p>The AnimationContainer is a base type for several kinds of animation containers. The
          Animationcontainer provides functionality common to all types of animation containers.
          Each animation container can contain only one type of keyframe. For example, most
          animation containers store Scalar keyframes, and therefore return a Scalar value during
          evaluation. However, AnimationContainers can also store 'Color', or 'Quat' values. </p><div class="table"><a name="d5e1831"></a><p class="title"><b>Table&nbsp;18.56.&nbsp;AnimationContainer Options</b></p><div class="table-contents"><table summary="AnimationContainer Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>controllerNode</td><td>The controller node used to control the evaluated time value can be passed
                  into the constructor.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1840"></a><p class="title"><b>Table&nbsp;18.57.&nbsp;AnimationContainer Methods</b></p><div class="table-contents"><table summary="AnimationContainer Methods" border="0"><colgroup><col width="249" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getValueType</td><td>Returns the data type that this animation container evaluates to.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="TrackAnimationContainer"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1852"></a>TrackAnimationContainer</h3></div></div></div><p>ParentNode: <span class="bold"><strong>AnimationContainer</strong></span></p><p>The TrackAnimationContainer stores a set of tracks of the same type. The
          TrackAnimationContainer is a base type for all 'Track Containers'. </p><div class="table"><a name="d5e1857"></a><p class="title"><b>Table&nbsp;18.58.&nbsp;TrackAnimationContainer Options</b></p><div class="table-contents"><table summary="TrackAnimationContainer Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>keyframetype</td><td>The type of keyframe this animation container will store.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1866"></a><p class="title"><b>Table&nbsp;18.59.&nbsp;TrackAnimationContainer Methods</b></p><div class="table-contents"><table summary="TrackAnimationContainer Methods" border="0"><colgroup><col width="249" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>getTimeRange</td><td>Returns the time range for all keys stored in all tracks. </td></tr><tr><td>getTrack/setTrack</td><td>Gets or sets an individual track.</td></tr><tr><td>getTracks/setTracks</td><td>Gets or sets all the tracks in the container.</td></tr><tr><td>getTrackCount</td><td>Returns the number of tracks the container holds.</td></tr><tr><td>setValues</td><td>Used by the manipulation system. Used to create keyframes on the tracks by
                  setting new values at a given time.</td></tr><tr><td>bindNodeMembersToTracks</td><td>The tracks stored in a track container can be bound to memebrs on nodes in
                  the graph. This function generates an operator that evaluates the given tracks and
                  setting the bound member to the returned value.</td></tr><tr><td>openCurveEditor</td><td>Opens the curve editor to display the tracks in the container.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="CharacterAnimationContainer"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1893"></a>CharacterAnimationContainer</h3></div></div></div><p>ParentNode: <span class="bold"><strong>AnimationContainer</strong></span></p><p>The CharacterAnimationContainer stores multiple sets of tracks of the same type. The
          CharacterAnimationContainer is a base type for track containers used in character
          animation. Each slice of the Dependency Graph Node stores a complete set of animation
          tracks. This enables a single CharacterAnimationContainer node to store a library of
          character animations. Storing all the character animations in a single node enables a
          character to dynamicaly select which set of animations it is evaluating, enabling such
          things as non-linear animation editing, animation blending, and crowd simulation.</p><div class="table"><a name="d5e1898"></a><p class="title"><b>Table&nbsp;18.60.&nbsp;CharacterAnimationContainer Options</b></p><div class="table-contents"><table summary="CharacterAnimationContainer Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>keyframetype</td><td>The type of keyframe this animation container will store.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1907"></a><p class="title"><b>Table&nbsp;18.61.&nbsp;CharacterAnimationContainer Methods</b></p><div class="table-contents"><table summary="CharacterAnimationContainer Methods" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>addTrackSet</td><td>Adds a new track set to the container. The bindings used to evaluate the
                  track set must also be provided.</td></tr><tr><td>getTimeRange</td><td>Returns the time range for all keys stored in all tracks. </td></tr><tr><td>getTrack/setTrack</td><td>Gets or sets an individual track.</td></tr><tr><td>getTracks/setTracks</td><td>Gets or sets all the tracks in the container.</td></tr><tr><td>getTrackSetCount</td><td>Returns the number of track sets stored in the container.</td></tr><tr><td>setValues</td><td>Used by the manipulation system. Used to create keyframes on the tracks by
                  setting new values at a given time. </td></tr><tr><td>bindToRig</td><td>Binds the animation tracks to a rig. This function is used when generating
                  keyframes for a rig, based on the motion of a different rig. </td></tr><tr><td>plotKeyframes</td><td>Once an animation container is bound to a rig, the tracks can be plotted
                  using leanrly spaced keyframes.</td></tr><tr><td>openCurveEditor</td><td>Opens the curve editor to display the tracks in the container.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e1940"></a><p class="title"><b>Table&nbsp;18.62.&nbsp;CharacterAnimationContainer Methods</b></p><div class="table-contents"><table summary="CharacterAnimationContainer Methods" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>addTrackSet</td><td>Adds a new track set to the container. The bindings used to evaluate the
                  track set must also be provided.</td></tr><tr><td>getTimeRange</td><td>Returns the time range for all keys stored in all tracks. </td></tr><tr><td>getTrack/setTrack</td><td>Gets or sets an individual track.</td></tr><tr><td>getTracks/setTracks</td><td>Gets or sets all the tracks in the container.</td></tr><tr><td>getTrackSetCount</td><td>Returns the number of track sets stored in the container.</td></tr><tr><td>setValues</td><td>Used by the manipulation system. Used to create keyframes on the tracks by
                  setting new values at a given time. </td></tr><tr><td>bindToRig</td><td>Binds the animation tracks to a rig. This function is used when generating
                  keyframes for a rig, based on the motion of a different rig. </td></tr><tr><td>plotKeyframes</td><td>Once an animation container is bound to a rig, the tracks can be plotted
                  using leanrly spaced keyframes.</td></tr><tr><td>openCurveEditor</td><td>Opens the curve editor to display the tracks in the container.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="LinearTrackAnimationContainer"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1973"></a>LinearTrackAnimationContainer</h3></div></div></div><p>ParentNode: <span class="bold"><strong>TrackAnimationContainer</strong></span></p><p>The LinearTrackAnimationContainer stores tracks or type LinearKeyframe.</p></div><div class="section" title="LinearCharacterAnimationContainer"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1978"></a>LinearCharacterAnimationContainer</h3></div></div></div><p>ParentNode: <span class="bold"><strong>CharacterAnimationContainer</strong></span></p><p>The LinearCharacterAnimationContainer stores tracks or type LinearKeyframe.</p></div><div class="section" title="BezierTrackAnimationContainer"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1983"></a>BezierTrackAnimationContainer</h3></div></div></div><p>ParentNode: <span class="bold"><strong>TrackAnimationContainer</strong></span></p><p>The LinearCharacterAnimationContainer stores tracks or type BezierKeyframe.</p></div></div><div class="section" title="Persistence.js"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e1988"></a>Persistence.js</h2></div></div></div><div class="section" title="SceneSerializer"><div class="titlepage"><div><div><h3 class="title"><a name="d5e1990"></a>SceneSerializer</h3></div></div></div><p>ParentNode: <span class="bold"><strong>SceneGraphNode</strong></span></p><p>The SceneSerializer manages the persistence of objects. Scene Graph nodes are added to
          the SceneSerializer, and the serializer invokes the weriteData methods on each node. The
          SceneSerializer also manages storing nodes in order of thier dendencies. By adding a node,
          all of that nodes dependencies are also added to the SceneSerializer, unless they are
          filtered by the type, or name filters. </p><div class="table"><a name="d5e1995"></a><p class="title"><b>Table&nbsp;18.63.&nbsp;SceneSerializer Options</b></p><div class="table-contents"><table summary="SceneSerializer Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>filteredNodeTypes</td><td>An Array of strings specifying node types that should not be saved by the
                  serializer. This is usefull for avoiding saving such things as Cameras and
                  Manipulators to your persisted storage.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e2004"></a><p class="title"><b>Table&nbsp;18.64.&nbsp;SceneSerializer Methods</b></p><div class="table-contents"><table summary="SceneSerializer Methods" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>addNode</td><td>Add a node to the SceneSerializer to be stored.</td></tr><tr><td>filterNode</td><td>Filter this node, ensuring it will not be saved.</td></tr><tr><td>serialize</td><td>Invoke the serialization of all added nodes. </td></tr><tr><td>save</td><td>Write the serialized data to the given storage system.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="SceneDeserializer"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2022"></a>SceneDeserializer</h3></div></div></div><p>ParentNode: <span class="bold"><strong>SceneGraphNode</strong></span></p><p>The SceneDeserializer loads data from a given storage medium, and constructs node, and
          loads thier data.</p><div class="table"><a name="d5e2027"></a><p class="title"><b>Table&nbsp;18.65.&nbsp;SceneDeserializer Options</b></p><div class="table-contents"><table summary="SceneDeserializer Options" border="0"><colgroup><col width="250" class="c1"><col width="400" class="c2"></colgroup><tbody><tr><td>preLoadScene</td><td>If set to true, the all the nodes in the current scene are preloaded.
                </td></tr><tr><td>filteredNodeTypes</td><td>An Array of strings specifying node types that should not be loaded by the
                  deserializer. This is usefull for avoiding loading such things as Cameras and
                  Manipulators to your persisted storage.</td></tr><tr><td>&nbsp;</td><td>&nbsp;</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d5e2042"></a><p class="title"><b>Table&nbsp;18.66.&nbsp;SceneDeserializer Methods</b></p><div class="table-contents"><table summary="SceneDeserializer Methods" border="0"><colgroup><col width="179" class="c1"><col width="117" class="newCol2"><col width="396" class="c2"></colgroup><tbody><tr><td>setPreLoadedNode</td><td>node</td><td>Preload a node into the SceneDeserializer. During deserialization, if a node
                  has been preloaded, and data for a stored node matches the preloaeded node, then
                  the data is loaded onto the preloaded node. This is usefull for loading presets
                  into existing scenes.</td></tr><tr><td>load</td><td>storage, callback</td><td>Passing a storage interface, and a callback, the load function retrieves the
                  data from the storage, and constructs the graph and/or loads dta into the
                  preloaded nodes.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="LogWriter"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2057"></a>LogWriter</h3></div></div></div><p>The LogWriter is a storage inteface used only in debugging. Instead of storing the
          data generated by the SceneSerializer, it simply logs the data to the console.</p></div><div class="section" title="LocalStorage"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2060"></a>LocalStorage</h3></div></div></div><p>The LocalStorage is used to write data to the HTML5 local storage supported in modern
          browsers. This usefull when the size of the data is small, and also does not require a
          confimation from the user.</p></div><div class="section" title="FileWriter"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2063"></a>FileWriter</h3></div></div></div><p>The FileWriter is a storage inteface used by the scene serializer to write out JSON
          text files to the users hard drive.</p></div><div class="section" title="FileWriterWithBinary"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2066"></a>FileWriterWithBinary</h3></div></div></div><p>The FileWriterWithBinary is a storage inteface used by the scene serializer to write
          out JSON text files to the users hard drive, along with an accompanying binary data file.
          The binary data file ise valuable when the size of the data is very large. The binary data
          file is written using ZLib to compress the data, resulting in compact data files.</p></div><div class="section" title="FileReader"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2069"></a>FileReader</h3></div></div></div><p>The FileWriter is a storage inteface used by the scene deserializer to load and read
          JSON text files from the users hard drive.The Fire reader prompts the user to pick a file
          on construction.</p></div><div class="section" title="XHRReader"><div class="titlepage"><div><div><h3 class="title"><a name="d5e2072"></a>XHRReader</h3></div></div></div><p>The XHRReader is a storage inteface used to retrieve data via URLs through
          XMLHttpRequests. </p></div></div></div></div></body></html>