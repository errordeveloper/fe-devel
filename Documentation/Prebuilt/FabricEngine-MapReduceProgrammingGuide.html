<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>Map Reduce Programming Guide</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="Map Reduce Programming Guide"><div class="titlepage"><div><div><h1 class="title"><a name="d5e1"></a>Map Reduce Programming Guide</h1></div><div><p class="releaseinfo">Fabric Engine Version 1.2.0-beta</p></div><div><p class="copyright">Copyright Â© 2010-2012 Fabric Engine Inc.</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#d5e8">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e19">Background</a></span></dt><dt><span class="section"><a href="#d5e55">Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e58">Producers</a></span></dt><dt><span class="section"><a href="#d5e97">Types of Producers</a></span></dt><dt><span class="section"><a href="#d5e113">Reduce</a></span></dt><dt><span class="section"><a href="#d5e124">Caches</a></span></dt><dt><span class="section"><a href="#d5e130">Composing Producers and Reduce Operations</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d5e138">2. KL Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e141">KL Constant Producers</a></span></dt><dt><span class="section"><a href="#d5e158">KL Generators</a></span></dt><dt><span class="section"><a href="#d5e195">KL Maps</a></span></dt><dt><span class="section"><a href="#d5e240">KL Transforms</a></span></dt><dt><span class="section"><a href="#d5e286">KL Reduce Operations</a></span></dt><dt><span class="section"><a href="#d5e316">KL Caches</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d5e330">3. Scripting Language Implementations (JavaScript/Python)</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e333">Creating a <code class="code">client</code> object</a></span></dt><dt><span class="section"><a href="#d5e343">Compilation of KL Code</a></span></dt><dt><span class="section"><a href="#d5e393">Asynchronous Production</a></span></dt><dt><span class="section"><a href="#d5e409">Using a Single Fabric Client for Multiple Computations</a></span></dt><dt><span class="section"><a href="#d5e413">Constant Producers</a></span></dt><dt><span class="section"><a href="#d5e431">Generators</a></span></dt><dt><span class="section"><a href="#d5e453">Maps</a></span></dt><dt><span class="section"><a href="#d5e471">Transforms</a></span></dt><dt><span class="section"><a href="#d5e485">Reduce</a></span></dt><dt><span class="section"><a href="#d5e514">Caches</a></span></dt></dl></dd></dl></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title"><a name="d5e8"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e19">Background</a></span></dt><dt><span class="section"><a href="#d5e55">Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e58">Producers</a></span></dt><dt><span class="section"><a href="#d5e97">Types of Producers</a></span></dt><dt><span class="section"><a href="#d5e113">Reduce</a></span></dt><dt><span class="section"><a href="#d5e124">Caches</a></span></dt><dt><span class="section"><a href="#d5e130">Composing Producers and Reduce Operations</a></span></dt></dl></dd></dl></div><p>
Fabric has traditionally provided access to parallelism through use of of its dependency graph to structure computation and data. However, the dependency graph has several shortcomings, especially when used for server-side computation:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
Constructing dependency graphs takes a lot of code. Even the simplest dependency graph requires the creation and connection of several different objects.
</p></li><li class="listitem"><p>
Since the data in the dependency graph is persistent, it tends to incur a heavy memory overhead.
</p></li><li class="listitem"><p>
Dependency graphs cannot be created or modified from within KL itself.
</p></li></ul></div><p>
To solve these problems, Fabric provides a separate model of parallel programming called "Map-Reduce" that is inspired by models of parallelism provided by functional programming languages and commercial MapReduce frameworks for large-scale computing. The map-reduce functionality is available both within KL and from the host language such as JavaScript or Python. It is simple to use, provides highly-parallel performance and incurs a minimal memory overhead.
</p><div class="section" title="Background"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e19"></a>Background</h2></div></div></div><p>Traditionally, the map-reduce paradigm provides a simple way of performing parallel operations on large sets of data. The input to map-reduce is a large array of data whose elements are of a common type, and the output is a single value of another type. The output is produced from the input by performing the following steps:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
For each input element <code class="code">Xi</code> in the input array <code class="code">[x1,x2,...xn]</code>, the value <code class="code">mi = map(xi)</code> is computed. This can be done for the input elements in parallel.
</p></li><li class="listitem"><p>
The result <code class="code">R = reduce([M1,M2,...,Mn])</code> is computed by combining the results of the map operations.
</p></li></ul></div><p>
The canonical example of a map-reduce operation is to count the number of occurrences of a given word in a large set of documents (for simplicity, strings). Then the <code class="code">map(Xi)</code> operation counts the number of occurrences of the word in the string <code class="code">Xi</code>, and the <code class="code">reduce([M1,M2,...,Mn])</code> operation simply sums the results of all the <code class="code">Mi</code>.
</p><p>
There are several problems with map-reduce in its simplest form:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
The individual <code class="code">Xi</code> themselves might be values that need to be computed and/or that take a lot of memory. As such, it makes sense to retrieve (or compute) the value <code class="code">Xi</code> right before computing <code class="code">map(Xi)</code> and then to immediately throw away the value of <code class="code">Xi</code>.
</p></li><li class="listitem"><p>
Instead of computing <code class="code">reduce([M1,M2,...,Mn])</code> once all the <code class="code">Mi</code> are computed, we use less memory and make better use of parallelism by accumulating the result. First we initialize <code class="code">R</code> to a default value, and then as each <code class="code">Mi</code> is computed we compute <code class="code">R = reduce(R, Mi)</code>. Once this is done for all the <code class="code">Mi</code>, we return the resulting <code class="code">R</code>. We must use a mutex to guarantee that <code class="code">reduce(R, Mi)</code> is only ever executed by one thread at a time.
</p></li></ul></div><p>
Fabric addresses these issues as well as others to provide a more general framework for parallel computation inspired by the traditional map-reduce case.
</p></div><div class="section" title="Concepts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e55"></a>Concepts</h2></div></div></div><p>
Map-reduce in Fabric has a more generic and powerful implementation that arises from a core set of concepts and operations. The traditional map-reduce case is then just a specific case of what can be done with the Fabric map-reduce framework. All of the concepts and operations are available both within KL programs and are accessible using the host language interface to the Fabric core.
</p><div class="section" title="Producers"><div class="titlepage"><div><div><h3 class="title"><a name="d5e58"></a>Producers</h3></div></div></div><p>
The first concept is the notion of a <span class="emphasis"><em>producer</em></span>. A producer is a first-class object whose methods can be used to produce scalar and vector values; these values can be any of the core types in Fabric, and registered (user-defined) types, or even more producers.
</p><p>
There are two classes of producers in Fabric, described below.
</p><div class="section" title="Value Producers"><div class="titlepage"><div><div><h4 class="title"><a name="d5e63"></a>Value Producers</h4></div></div></div><p>
A <span class="emphasis"><em>value producer</em></span> is a producer that can produce a scalar value; it has the method <code class="code">produce()</code> that returns the value, as well as the method <code class="code">flush()</code> that flushes any cached values (see the 'Caches' section below).
</p></div><div class="section" title="Array Producers"><div class="titlepage"><div><div><h4 class="title"><a name="d5e69"></a>Array Producers</h4></div></div></div><p>
An <span class="emphasis"><em>array producer</em></span> is a producer that can produce an array (vector) of elements; it has five methods:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
<code class="code">getCount()</code>: returns the number of elements in the array
</p></li><li class="listitem"><p>
<code class="code">produce(index)</code>: returns the element of the array with index <code class="code">index</code>
</p></li><li class="listitem"><p>
<code class="code">produce(startIndex, count)</code>: returns the subarray of <code class="code">count</code> elements of the array starting with index <code class="code">startIndex</code>
</p></li><li class="listitem"><p>
<code class="code">produce()</code>: returns the array of all elements
</p></li><li class="listitem"><p>
<code class="code">flush()</code>: flushes any cached values (see the 'Caches' section below).
</p></li></ul></div><p>
The indices are zero-based, as in KL. All the the array elements have the same type; in a strong sense, an array producer is an object that can be used to populate a variable-length KL array.
</p><p>
Note that an array producer specifies how to produce the elements of an array without actually producing them. This means that you can create an array produce for an array with billions of elements and it takes no more memory than an array producer for one element; it's only when the elements are produced that the results may be stored, depending on how the results are used.
</p><p>
The <code class="code">produce()</code> and <code class="code">produce(startIndex, count)</code> methods produce the individual elements of the array in parallel.
</p></div></div><div class="section" title="Types of Producers"><div class="titlepage"><div><div><h3 class="title"><a name="d5e97"></a>Types of Producers</h3></div></div></div><p>
For each class (value or array) of producer, there are four basic types of producers that produce values in different ways.
</p><div class="section" title="Constant Producers"><div class="titlepage"><div><div><h4 class="title"><a name="d5e100"></a>Constant Producers</h4></div></div></div><p>
A constant producer has fixed values that are produced. It does not need to execute any code to produce its values, and the values it produces are specified when the constant producer is created.
</p></div><div class="section" title="Generators"><div class="titlepage"><div><div><h4 class="title"><a name="d5e103"></a>Generators</h4></div></div></div><p>
A generator is a producer that calls a function to produce its value. In the case of an array producer, the function that is called can optionally receive the index within the array and the total number of elements of the array; these can be used to calculate the element to generate. Both value and array producers can optionally take a "shared value" which can be used to pass things like shared parameters to the generator. The shared value is itself the result of calling <code class="code">produce()</code> on a value producer, which means that it can itself potentially be a calculated value.
</p></div><div class="section" title="Maps"><div class="titlepage"><div><div><h4 class="title"><a name="d5e107"></a>Maps</h4></div></div></div><p>
A map is a producer that takes as input a value of one type and produces from it a value of another, potentially different, type. An example of a simple map might be one that takes a string as input and produces the length of the string as output. As with generators, an array map can optionally take the index of the element being produced as well as the count of the array, and both value and array maps can take a shared value.
</p></div><div class="section" title="Transforms"><div class="titlepage"><div><div><h4 class="title"><a name="d5e110"></a>Transforms</h4></div></div></div><p>
A transform is a producer that modifies the value of another producer. The same behaviour could be accomplished using a map that uses the same type for input and output, but using a transform instead will require less memory and generally result in slightly better runtime performance. An example of a simple transform might be one that normalizes a vector. As with generators and maps, an array transform can optionally take the index of the element being produced as well as the count of the array, and both value and array transforms can take a shared value.
</p></div></div><div class="section" title="Reduce"><div class="titlepage"><div><div><h3 class="title"><a name="d5e113"></a>Reduce</h3></div></div></div><p>
The reduce operation is the bridge between array producers and value producers. A reduce operation takes an array producer and a function as input and returns a value producer as output. The reduce operation works by calling the function for each element produced by the array producer; this function is then used to progressively produce the result of reduce operation as a value producer. There are two guarantees for the function:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
The function is called exactly once for each element of the input array producer; and
</p></li><li class="listitem"><p>
The function is called by only one thread at a time so that no manual synchronization is necessary.
</p></li></ul></div><p>
However, the order in which the elements of the array producer is undefined, and as such algorithms cannot depend on this order.
</p><p>
As with generators, maps and transforms, the reduce function can optionally take the index of element of the input array producer as well as its total count, and you can optionally pass a shared value.
</p><p>
A simple example of a reduce operation would be to sum an array of values. The array producer would produce the individual values, and the reduce function would simply add each value to the result.
</p></div><div class="section" title="Caches"><div class="titlepage"><div><div><h3 class="title"><a name="d5e124"></a>Caches</h3></div></div></div><p>
A cache is a producer that simply caches the value of another producer. Caches are a simple solution for situations where the same results would be computed multiple times. As an example, if multiple producers all used the same shared value producer, it would probably make sense to put a value cache in front of the value producer so that it's not recomputed every time it's used.
</p><p>
All producers support a method called <code class="code">flush()</code> that recursively flushes any caches. So, for example, if you have a reduce operation that uses a shared value that is cached, calling <code class="code">flush()</code> on the reduce operation will flush the connected shared value cache.
</p></div><div class="section" title="Composing Producers and Reduce Operations"><div class="titlepage"><div><div><h3 class="title"><a name="d5e130"></a>Composing Producers and Reduce Operations</h3></div></div></div><p>
The power of Fabric's map-reduce model is found through the use of composition. Maps, transforms and reduce operations all take other producers as input and allow modification of the results. As well, generators, maps, transforms and reduce operations all optionally take shared values that are the results of the <code class="code">produce()</code> operation of a value producer; this value produce can in turn be a complex, composed operation such as a reduce operation on a map.
</p><p>
As an example, suppose you had a large set of documents and you wanted to count the occurrence of the longest word that occurs across all the documents; assume for the example that there is a unique longest word. You need to first figure out what this word is and then count it. The compositional model would be:
</p><pre class="programlisting">
    reduce(
      input: map(
        input: constArray(documents),
        function: countWord,
        sharedValue: reduce(
          input: map(
            input: constArray(documents),
            function: findLongestWord
            ),
          function: pickLongestWord
        ),
      function: sumValue
      )
</pre><p>
Then the functions would look something like:
</p><pre class="programlisting">
    operator findLongestWord(String document, io String longestWord) {
      // Set longestWord to the longest word in document
    }
    
    operator pickLongestWord(String word, io String longestWord) {
      if (word.length &gt; longestWord.length)
        longestWord = word;
    }
    
    operator countWord(String document, io Size count, String word) {
      // Set count to the number of occurrences of word in document
    }
    
    operator sumValue(Size count, io Size totalCount) {
      totalCount += count;
    }
</pre></div></div></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;KL Implementation"><div class="titlepage"><div><div><h2 class="title"><a name="d5e138"></a>Chapter&nbsp;2.&nbsp;KL Implementation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e141">KL Constant Producers</a></span></dt><dt><span class="section"><a href="#d5e158">KL Generators</a></span></dt><dt><span class="section"><a href="#d5e195">KL Maps</a></span></dt><dt><span class="section"><a href="#d5e240">KL Transforms</a></span></dt><dt><span class="section"><a href="#d5e286">KL Reduce Operations</a></span></dt><dt><span class="section"><a href="#d5e316">KL Caches</a></span></dt></dl></div><p>
As mentioned previously, the map-reduce model is available both directly in KL and directly from JavaScript or Python. Using the map-reduce model directly from within KL allows for simple multithreading directly from within KL itself, without the need to create structures within the host language.
</p><div class="section" title="KL Constant Producers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e141"></a>KL Constant Producers</h2></div></div></div><p>
In KL, a constant value producer is created using the <code class="code">createConstValue(value)</code> call. The value parameter can be any typed KL r-value, eg. a constant value, the value of a variable, or the result of a function call. The result of the value is a value of type <code class="code">ValueProducer&lt;ValueType&gt;</code>, where <code class="code">ValueType</code> is the type of <code class="code">value</code>. For example, the KL code:
</p><pre class="programlisting">
    operator entry() {
      ValueProducer&lt;Scalar&gt; vp = createConstValue(1.4142);
      report(vp.produce());
    }
</pre><p>
produces the result:
</p><pre class="screen">
    1.4142
</pre><p>
A constant array producer is created using the <code class="code">createConstArray(array)</code> function. Its single parameter array must be an expression that resolves to a fixed-length, variable-length or sliced array. The return value is of type <code class="code">ArrayProducer&lt;ElementType&gt;</code>, where <code class="code">ElementType</code> is the type of the array elements. For example, the KL code:
</p><pre class="programlisting">
    operator entry() {
      String a[];
      a.push('zero'); a.push('one'); a.push('two');
      ArrayProducer&lt;String&gt; ap = createConstArray(a);
      report(ap.produce());
    }
</pre><p>
produces the result:
</p><pre class="screen">
    ["zero","one","two"]
</pre></div><div class="section" title="KL Generators"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e158"></a>KL Generators</h2></div></div></div><p>
A value generator in KL is created using the <code class="code">createValueGenerator(functionName)</code>. <code class="code">functionName</code> must be the name of a KL function available in the same KL module that has the signature operator <code class="code">functionName(io ValueType value);</code> the result is a value of type <code class="code">ValueProducer&lt;ValueType&gt;</code>. For example, the KL code:
</p><pre class="programlisting">
    operator gen(io String value[]) {
      value.push("Hello, world!");
    }
    
    operator entry() {
      ValueProducer&lt;String[]&gt;vp = createValueGenerator(gen);
      report(vp.produce());
    }
</pre><p>
produces the output:
</p><pre class="screen">
    ["Hello, world!"]
</pre><p>
An array generator in KL is created using the <code class="code">createArrayGenerator(countValueProducer, functionName)</code>. The <code class="code">countValueProducer</code> parameter must be a value producer that produces a value of type <code class="code">Size</code>, ie. a value of type <code class="code">ValueProducer&lt;Size&gt;</code>. If you are generating a fixed-size array of size 16, for instance, you can pass the result of <code class="code">createConstValue(16)</code>, but you can also pass a more complex value producer such as a value generator. The functionName is the name of a function in the same module with one of the following prototypes:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
<code class="code">operator functionName(io ElementType element)</code>
</p></li><li class="listitem"><p>
<code class="code">operator functionName(io ElementType element, Index index)</code>
</p></li><li class="listitem"><p>
<code class="code">operator functionName(io ElementType element, Index index, Size count)</code>
</p></li></ul></div><p>
In cases where the index parameter is present, the index of the element within the array is passed to the generator function; similarly, when the count parameter is present the total number of elements in the array is passed. This can be useful for figuring out what value to generate.
</p><p>
An example of an array generator:
</p><pre class="programlisting">
    operator gen(
      io Scalar v,
      Index i,
      Size n
      )
    {
      // Produces n uniform values on the interval [0,1], including 0 and 1 themselves
      v = Scalar(i) / Scalar(n-1);
    }
    
    operator entry() {
      ArrayProducer&lt;Scalar&gt; ap = createArrayGenerator(createConstValue(Size(10)), gen);
      report(ap.produce());
    }
</pre><p>
produces:
</p><pre class="screen">
    [0,0.1111111,0.2222222,0.3333333,0.4444444,0.5555556,0.6666667,0.7777778,0.8888889,1]
</pre><p>
In both cases, you can optionally specify a shared value producer as the last parameter to the <code class="code">create...Generator()</code> call. When a shared value producer is provided, the function receives an additional parameter whose type is the value type of the shared value producer. So, for value generators, the prototype of the operator becomes:
</p><pre class="programlisting">
    operator gen(io ValueType value, SharedType sharedValue) {
      ...
    }
</pre><p>
and for array generators the prototype of the operator becomes:
</p><pre class="programlisting">
    operator gen(io ElementType element, Index index, Size count, SharedType sharedValue) {
    
      ...
    }
</pre><p>
Note that when using a shared value with an array generator you must include the index and count parameters in the operator even if they are unused.
</p></div><div class="section" title="KL Maps"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e195"></a>KL Maps</h2></div></div></div><p>
A value map in KL is created using the <code class="code">createValueMap(inputValueProducer, functionName)</code>. <code class="code">inputValueProducer</code> must be a value producer, and <code class="code">functionName</code> must be the name of a KL function available in the same KL module that has the signature operator <code class="code">functionName(InputType input, io OutputType output);</code> the type <code class="code">InputType</code> must be the same as the value type of the input value producer. The result of the <code class="code">createValueMap</code> call is a value of type <code class="code">ValueProducer&lt;OutputType&gt;</code>. For example, the KL code:
</p><pre class="programlisting">
    operator map(String input, io Size output) {
      output = input.length;
    }
    
    operator entry() {
      ValueProducer&lt;Size&gt; vp = createValueMap(createConstValue("Hello, world!"), map);
      report(vp.produce());
    }
</pre><p>
produces the output:
</p><pre class="screen">
    13
</pre><p>
An array map in KL is created using the <code class="code">createArrayMap(inputArrayProducer, functionName)</code>. The <code class="code">inputArrayProducer</code> parameter must be an array producer. Assuming that the element type of <code class="code">inputArrayProducer</code> is <code class="code">InputType</code>, <code class="code">functionName</code> is the name of a function in the same module with one of the following prototypes:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
<code class="code">operator functionName(InputType input, io OutputType output)</code>
</p></li><li class="listitem"><p>
<code class="code">operator functionName(InputType input, io OutputType output, Index index)</code>
</p></li><li class="listitem"><p>
<code class="code">operator functionName(InputType input, io OutputType output, Index index, Size count)</code>
</p></li></ul></div><p>
In cases where the <code class="code">index</code> parameter is present, the index of the element within the array is passed to the generator function; similarly, when the count parameter is present the total number of elements in the array is passed. The result of the <code class="code">createArrayMap</code> call is a value of type <code class="code">ArrayProducer&lt;OutputType&gt;</code>.
</p><p>
An example of an array map:
</p><pre class="programlisting">
    operator map(String input, io Size output) {
      output = input.length;
    }
    
    operator entry() {
      String a[]; a.push("one"); a.push("two"); a.push("three");
      ArrayProducer&lt;String&gt; iap = createConstArray(a);
      report(iap.produce());
      ArrayProducer&lt;Size&gt; oap = createArrayMap(iap, map);
      report(oap.produce());
    }
</pre><p>
produces:
</p><pre class="screen">
    ["one","two","three"]
    [3,3,5]
</pre><p>
In both cases, you can optionally specify a shared value producer as the last parameter to the <code class="code">create...Map()</code> call. When a shared value producer is provided, the function receives an additional parameter whose type is the value type of the shared value producer. So, for value maps, the prototype of the operator becomes:
</p><pre class="programlisting">
    operator gen(InputType input, io OutputType output, SharedType sharedValue) {
      ...
    }
</pre><p>
and for array maps the prototype of the operator becomes:
</p><pre class="programlisting">
    operator gen(InputType input, io OutputType output, Index index, Size count, SharedType sharedValue) {
      ...
    }
</pre><p>
Note that when using a shared value with an array map you must include the <code class="code">index</code> and <code class="code">count</code> parameters in the operator even if they are unused.
</p></div><div class="section" title="KL Transforms"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e240"></a>KL Transforms</h2></div></div></div><p>
A value transform in KL is created using the <code class="code">createValueTransform(inputValueProducer, functionName)</code>. <code class="code">inputValueProducer</code> must be a value producer, and <code class="code">functionName</code> must be the name of a KL function available in the same KL module that has the signature operator <code class="code">functionName(io ValueType value)</code>; the type <code class="code">ValueType</code> must be the same as the value type of the input value producer. The result of the <code class="code">createValueMap</code> call is a value of type <code class="code">ValueProducer&lt;ValueType&gt;</code>. For example, the KL code:
</p><pre class="programlisting">
    operator transform(io Scalar value) {
      value = sqrt(value);
    }
    
    operator entry() {
      ValueProducer&lt;Scalar&gt; vp = createValueTransform(createConstValue(Scalar(3.14)), transform);
      report(vp.produce());
    }
</pre><p>
produces the output:
</p><pre class="screen">
    1.772004
</pre><p>
An array transform in KL is created using the <code class="code">createArrayTransform(inputArrayProducer, functionName)</code>. The <code class="code">inputArrayProducer</code> parameter must be an array producer. Assuming that the element type of <code class="code">inputArrayProducer</code> is <code class="code">ElementType</code>, <code class="code">functionName</code> is the name of a function in the same module with one of the following prototypes:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
<code class="code">operator functionName(io ElementType element)</code>
</p></li><li class="listitem"><p>
<code class="code">operator functionName(io ElementType element, Index index)</code>
</p></li><li class="listitem"><p>
<code class="code">operator functionName(io ElementType element, Index index, Size count)</code>
</p></li></ul></div><p>
In cases where the <code class="code">index</code> parameter is present, the index of the element within the array is passed to the generator function; similarly, when the <code class="code">count</code> parameter is present the total number of elements in the array is passed. The result of the <code class="code">createArrayTransform</code> call is a value of type <code class="code">ArrayProducer&lt;ElementType&gt;</code>.
</p><p>
An example of an array transform:
</p><pre class="programlisting">
    operator transform(io Scalar value) {
      value = sqrt(value);
    }
    
    operator entry() {
      Scalar ia[]; ia.push(3.14); ia.push(2.71); ia.push(10.0); ia.push(87.32);
      ArrayProducer&lt;Scalar&gt; iap = createConstArray(ia);
      report(iap.produce());
      ArrayProducer&lt;Scalar&gt; oap = createArrayTransform(iap, transform);
      report(oap.produce());
    }
</pre><p>
produces:
</p><pre class="screen">
    [3.14,2.71,10,87.32]
    [1.772004,1.646208,3.162278,9.344517]
</pre><p>
In both cases, you can optionally specify a shared value producer as the last parameter to the <code class="code">create...Transform()</code> call. When a shared value producer is provided, the function receives an additional parameter whose type is the value type of the shared value producer. So, for value maps, the prototype of the operator becomes:
</p><pre class="programlisting">
    operator gen(io ValueType value, SharedType sharedValue) {
      ...
    }
</pre><p>
and for array maps the prototype of the operator becomes:
</p><pre class="programlisting">
    operator gen(io ElementType element, Index index, Size count, SharedType sharedValue) {
      ...
    }
</pre><p>
Note that when using a shared value with an array map you must include the <code class="code">index</code> and <code class="code">count</code> parameters in the operator even if they are unused.
</p></div><div class="section" title="KL Reduce Operations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e286"></a>KL Reduce Operations</h2></div></div></div><p>
To create a reduce operation in KL, use the <code class="code">createReduce(inputArrayProducer, functionName)</code> call. <code class="code">inputArrayProducer</code> must be an array producer; assume its element type is <code class="code">InputType</code>. <code class="code">functionName</code> must be the name of a function in the same module with one of the prototypes:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
<code class="code">operator functionName(InputType input, io OutputType output)</code>
</p></li><li class="listitem"><p>
<code class="code">operator functionName(InputType input, io OutputType output, Index index)</code>
</p></li><li class="listitem"><p>
<code class="code">operator functionName(InputType input, io OutputType output, Index index, Size count)</code>
</p></li></ul></div><p>
The result of the <code class="code">createReduce</code> call is a value producer with value type <code class="code">OutputType</code>, ie. a result of type <code class="code">ValueProducer&lt;OutputType&gt;</code>. An example of using a reduce operation in KL:
</p><pre class="programlisting">
    operator generate(io Size value, Index index) {
      value = index + 1;
    }
    
    operator reduce(Size input, io Size output) {
      output += input;
    }
    
    operator entry() {
      // Report the sum 1+2+...+99+100
      ValueProducer&lt;Size&gt; vp = createReduce(
        createArrayGenerator(
          createConstValue(Size(100)),
          generate
        ),
        reduce
      );
      report(vp.produce());
    }
</pre><p>
This produces the result:
</p><pre class="screen">
    5050
</pre><p>
You can optionally specify a shared value producer as the last parameter to the <code class="code">createReduce()</code> call. When a shared value producer is provided, the function receives an additional parameter whose type is the value type of the shared value producer. The prototype of the operator becomes:
</p><pre class="programlisting">
    operator reduce(InputType input, io OutputType output, Index index, Size count, SharedType sharedValue) {
      ...
    }
</pre><p>
Note that when using a shared value with an array map you must include the <code class="code">index</code> and <code class="code">count</code> parameters in the operator even if they are unused.
</p></div><div class="section" title="KL Caches"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e316"></a>KL Caches</h2></div></div></div><p>
A value cache is created in KL using the <code class="code">createValueCache(inputValueProducer)</code> call. The element type of the resulting value producer is the same as that of <code class="code">inputValueProducer</code>. Example usage of a value cache in KL:
</p><pre class="programlisting">
    operator gen(io String output) {
      report("  Running generator!");
      output = "Hello";
    }
    
    operator entry() {
      // test caching ValueGenerator
      ValueProducer&lt;String&gt; vp1 = createValueCache(createValueGenerator(gen));
      report("vp1 = " + vp1);
              
      report("Should run generator");
      report("vp1.produce() = " + vp1.produce());
                  
      report("Should not run generator (use cache)");
      report("vp1.produce() = " + vp1.produce());
                      
      vp1.flush();
      report("Should run generator");
      report("vp1.produce() = " + vp1.produce());
    }
</pre><p>
resulting in:
</p><pre class="screen">
    vp1 = ValueProducer&lt;String&gt;
    Should run generator
      Running generator!
    vp1.produce() = Hello
    Should not run generator (use cache)
    vp1.produce() = Hello
    Should run generator
      Running generator!
    vp1.produce() = Hello
</pre><p>
Similarly, an array cache is created using the <code class="code">createArrayProducer(inputArrayProducer)</code> call. The resulting array producer has the same element type as <code class="code">inputArrayProducer</code>. Example usage:
</p><pre class="programlisting">
    operator generator(
      io Integer value
      )
    {
      report("  Running generator");
      value = 42;
    }
    
    operator entry() {
      // Generator caching
      ValueProducer&lt;Size&gt; cvg = createConstValue(Size(10));
      ArrayProducer&lt;Integer&gt; gen = createArrayCache(
        createArrayGenerator(cvg, generator)
        );
    
      report(gen);
      report(" gen.getCount() = " + gen.getCount());
    
      report("Should run generator 10x");
      for (Index i=0; i&lt;10; ++i)
        report(" gen.produce() = " + gen.produce(i));
    
      report("Should not run generator (cached)");
      for (Index i=0; i&lt;10; ++i)
        report(" gen.produce() = " + gen.produce(i));
    
      gen.flush();
      report("Should run generator 10x");
      for (Index i=0; i&lt;10; ++i)
        report(" gen.produce() = " + gen.produce(i));
    }
</pre><p>
resulting in:
</p><pre class="screen">
    ArrayProducer&lt;Integer&gt;
     gen.getCount() = 10
    Should run generator 10x
      Running generator
     gen.produce() = 42
      Running generator
     gen.produce() = 42
      Running generator
     gen.produce() = 42
      Running generator
     gen.produce() = 42
      Running generator
     gen.produce() = 42
      Running generator
     gen.produce() = 42
      Running generator
     gen.produce() = 42
      Running generator
     gen.produce() = 42
      Running generator
     gen.produce() = 42
      Running generator
     gen.produce() = 42
    Should not run generator (cached)
     gen.produce() = 42
     gen.produce() = 42
     gen.produce() = 42
     gen.produce() = 42
     gen.produce() = 42
     gen.produce() = 42
     gen.produce() = 42
     gen.produce() = 42
     gen.produce() = 42
     gen.produce() = 42
    Should run generator 10x
      Running generator
     gen.produce() = 42
      Running generator
      Running transform
     tr.produce() = 2
      Running transform
     tr.produce() = 4
      Running transform
     tr.produce() = 6
      Running transform
     tr.produce() = 8
      Running transform
     tr.produce() = 10
      Running transform
     tr.produce() = 12
      Running transform
     tr.produce() = 14
      Running transform
     tr.produce() = 16
      Running transform
     tr.produce() = 18
</pre></div></div><div class="chapter" title="Chapter&nbsp;3.&nbsp;Scripting Language Implementations (JavaScript/Python)"><div class="titlepage"><div><div><h2 class="title"><a name="d5e330"></a>Chapter&nbsp;3.&nbsp;Scripting Language Implementations (JavaScript/Python)</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d5e333">Creating a <code class="code">client</code> object</a></span></dt><dt><span class="section"><a href="#d5e343">Compilation of KL Code</a></span></dt><dt><span class="section"><a href="#d5e393">Asynchronous Production</a></span></dt><dt><span class="section"><a href="#d5e409">Using a Single Fabric Client for Multiple Computations</a></span></dt><dt><span class="section"><a href="#d5e413">Constant Producers</a></span></dt><dt><span class="section"><a href="#d5e431">Generators</a></span></dt><dt><span class="section"><a href="#d5e453">Maps</a></span></dt><dt><span class="section"><a href="#d5e471">Transforms</a></span></dt><dt><span class="section"><a href="#d5e485">Reduce</a></span></dt><dt><span class="section"><a href="#d5e514">Caches</a></span></dt></dl></div><p>
All of the map-reduce functionality that is available directly in KL is also available from JavaScript and Python. Syntax between JavaScript and Python is nearly identical and therefore most examples will be given in JavaScript, unless there the corresponding Python implementation would be unclear.
</p><div class="section" title="Creating a client object"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e333"></a>Creating a <code class="code">client</code> object</h2></div></div></div><p>
Creating a <code class="code">client</code> object does differ between JavaScript and Python so we will describe it here once and then leave it out of further examples.
</p><p>
In JavaScript:
</p><pre class="programlisting">
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> client = require(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Fabric'</span>).createClient();
</pre><p>
And in Python:
</p><pre class="programlisting">
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">import</span> fabric
    client = fabric.createClient()
</pre><p>
The client object is the base from which the rest of the Map Reduce objects are created.
</p></div><div class="section" title="Compilation of KL Code"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e343"></a>Compilation of KL Code</h2></div></div></div><p>
In order to provide the KL code used for operators for map-reduce operations, a generic KL compilation framework has been provided.
</p><p>
For simple examples, functions for compiling operators directly have been provided:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
<code class="code">client.KLC.createValueGeneratorOperator</code>
</p></li><li class="listitem"><p>
<code class="code">client.KLC.createValueMapOperator</code>
</p></li><li class="listitem"><p>
<code class="code">client.KLC.createValueTransformOperator</code>
</p></li><li class="listitem"><p>
<code class="code">client.KLC.createArrayGeneratorOperator</code>
</p></li><li class="listitem"><p>
<code class="code">client.KLC.createArrayMapOperator</code>
</p></li><li class="listitem"><p>
<code class="code">client.KLC.createArrayTransformOperator</code>
</p></li><li class="listitem"><p>
<code class="code">client.KLC.createReduceOperator</code>
</p></li></ul></div><p>
Each of these functions take the parameters <code class="code">sourceName</code>, <code class="code">sourceCode</code>, <code class="code">operatorName</code>. <code class="code">sourceName</code> is the name of the source file to display when a compilation error occurs, <code class="code">sourceCode</code> is the actual KL source code, and <code class="code">operatorName</code> is the name of the operator that should result from the call. For example:
</p><pre class="programlisting">
    &gt; <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> reduce = client.KLC.createReduceOperator(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'reduce.kl'</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'operator reduce(Size input, io Size output) { output += input; }'</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'reduce'</span>);
    &gt; console.log(reduce.toJSON());
</pre><p>
results in:
</p><pre class="screen">
    { kind: 'ReduceOperator',
      entryName: 'reduce',
      ast: 
       [ { '+': 'Operator',
           returnExprType: '',
           body: [Object],
           friendlyName: 'reduce',
           entryName: 'reduce',
           params: [Object] } ] }
</pre><p>
which is a JSON representation of the operator. This operator can then be passed to a call to <code class="code">client.MR.createReduce(...)</code> as the operator parameter.
</p><p>
For more complex examples, it will make more sense to include one or more KL 'source files' into a single compilation unit and to then resolve the operators within. This is done using the <code class="code">client.KLC.createCompilation()</code>, <code class="code">compilation.addSourceFile(sourceName, sourceCode)</code>, <code class="code">compilation.run()</code> and <code class="code">executable.resolve...Operator()</code> functions. For example:
</p><pre class="programlisting">
    &gt; <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> compilation = fabricClient.KLC.createCompilation();
    &gt; compilation.addSource(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'generate.kl'</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'operator generate(io Size value, Index index) { value = index + 1; }'</span>);
    &gt; compilation.addSource(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'reduce.kl'</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'operator reduce(Size input, io Size output) { output += input; }'</span>);
    &gt; <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> executable = compilation.run();
    &gt; <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> reduce = executable.resolveReduceOperator(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'reduce'</span>);
    &gt; reduce.toJSON();
</pre><p>
results in:
</p><pre class="screen">
    { kind: 'ReduceOperator',
      entryName: 'reduce',
      ast: 
       [ { '+': 'Operator',
           returnExprType: '',
           body: [Object],
           friendlyName: 'generate',
           entryName: 'generate',
           params: [Object] },
         { '+': 'Operator',
           returnExprType: '',
           body: [Object],
           friendlyName: 'reduce',
           entryName: 'reduce',
           params: [Object] } ] }
</pre><p>
Note that the AST in the JSON representation in this case is larger; this is because the two "source files" we combined in a single compilation unit. Similarly, we could call:
</p><pre class="programlisting">
    &gt; <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> generate = executable.resolveArrayGeneratorOperator(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'generate'</span>);
    &gt; generate.toJSON();
</pre><p>
which results in:
</p><pre class="screen">
    { kind: 'ArrayGeneratorOperator',
      entryName: 'generate',
      ast: 
       [ { '+': 'Operator',
           returnExprType: '',
           body: [Object],
           friendlyName: 'generate',
           entryName: 'generate',
           params: [Object] },
         { '+': 'Operator',
           returnExprType: '',
           body: [Object],
           friendlyName: 'reduce',
           entryName: 'reduce',
           params: [Object] } ] }
</pre></div><div class="section" title="Asynchronous Production"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e393"></a>Asynchronous Production</h2></div></div></div><p>
In addition to the usual <code class="code">produce()</code> methods on value and array producers, the JavaScript and Python bindings also support <code class="code">produceAsync(callback)</code> methods. <code class="code">produceAsync(callback)</code> causes the produce operation to happen asynchronously (ie. in the background); when the operation is complete, the function callback is called, passing the result of the <code class="code">produce()</code> operation as the first parameter. This is very useful for servicing computation in the background without blocking the main thread.
</p><p>
For example, in JavaScript:
</p><pre class="programlisting">
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> cv = client.MR.createConstValue(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Size'</span>, <span class="hl-number">42</span>);
    cv.produceAsync(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span> (result) {
      console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Result is "</span> + result);
      fabricClient.close();
    });
    console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Waiting for result..."</span>);
</pre><p>
And in Python, since the syntax is slightly different:
</p><pre class="programlisting">
    cv = client.MR.createConstValue(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Size'</span>, <span class="hl-number">42</span>);
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">def</span> callback(result):
      <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">print</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Result is '</span> + result
      client.close()
    cv.produceAsync(callback)
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">print</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Waiting for result...'</span>
</pre><p>
will both produce:
</p><pre class="screen">
    Waiting for result...
    Result is 42
</pre><p>
Python programmers may ask how it is that the Python example doesn't simply exit immediately when it hits the end of file. This is because the Fabric Python module waits for all its clients to close before allowing the script to exit. If more control is required over when the clients will exit, the user can use the Fabric client's <code class="code">running()</code> method to both test whether or not the client object is still running, as well as to service any pending actions.
</p><pre class="programlisting">
    cv = client.MR.createConstValue(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Size'</span>, <span class="hl-number">42</span>);
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">def</span> callback(result):
      <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">print</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Result is '</span> + result
      client.close()
    cv.produceAsync(callback)
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">print</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Waiting for result...'</span>
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">while</span> client.running():
      <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-comment"># perform some other actions</span>
      <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">pass</span>
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">print</span> <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Program exiting...'</span>
</pre></div><div class="section" title="Using a Single Fabric Client for Multiple Computations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e409"></a>Using a Single Fabric Client for Multiple Computations</h2></div></div></div><p>
Unlike the dependency graph, it is safe to use a single Fabric client for multiple computations, as long as you create separate producers and reduce operations for each computation. In this way, the operators can be shared between the computations. A simple Node.js HTTP server to generate the Fibonacci numbers might look like:
</p><pre class="programlisting">
    fabric = require(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Fabric'</span>);
    http = require(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'http'</span>);
    fs = require(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'fs'</span>);
    
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> fabricClient = fabric.createClient();
    
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> fibonacciGeneratorOperator = fabricClient.KLC.createValueGeneratorOperator(
      <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fibonacci-mr.kl"</span>,
      fs.readFileSync(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fibonacci-mr.kl"</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"utf8"</span>),
      <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"fibonacci"</span>
    );
    
    http.createServer(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">function</span> (req, res) {
      <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> fibonacciGenerator = fabricClient.MR.createValueGenerator(
        fibonacciGeneratorOperator,
        fabricClient.MR.createConstValue(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Integer'</span>, <span class="hl-number">40</span>)
      );
      res.writeHead(<span class="hl-number">200</span>, {<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Content-Type'</span>: <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'text/plain'</span>});
      res.end(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\n"</span>+fibonacciGenerator.produce()+<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"\n"</span>);
    }).listen(<span class="hl-number">1337</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"127.0.0.1"</span>);
</pre></div><div class="section" title="Constant Producers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e413"></a>Constant Producers</h2></div></div></div><p>
In JavaScript and Python, a constant value producer is created using the <code class="code">client.MR.createConstValue(typeName, value)</code> call. The <code class="code">typeName</code> parameter is the name of the type of the value (eg. <code class="code">Size</code>), and the <code class="code">value</code> parameter is the value to use. The value is interpreted as the specified type; if no conversion is possible an error results. For example, the JavaScript code:
</p><pre class="programlisting">
    client.MR.createConstValue(
      <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Scalar'</span>,
      <span class="hl-number">1.4142</span>
    ).produce();
</pre><p>
produces the result:
</p><pre class="screen">
    1.414199948310852
</pre><p>
(since floating-point numbers are 64-bit in JavaScript)
</p><p>
A constant array producer is created using the <code class="code">client.MR.createConstArray(elementTypeName, array)</code> function. The <code class="code">elementTypeName</code> parameter is the name of the element type of the resulting array producer, and the <code class="code">array</code> parameter must be an array of values that can be casted to the specified element type. For example, the JavaScript code:
</p><pre class="programlisting">
    client.MR.createConstArray(
      <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Scalar'</span>,
      [<span class="hl-number">1.4142</span>, <span class="hl-number">3.14159</span>, <span class="hl-number">2.718281</span>]
    ).produce();
</pre><p>
produces the result:
</p><pre class="screen">
    [ 1.414199948310852,
      3.141590118408203,
      2.718281030654907 ]
</pre></div><div class="section" title="Generators"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e431"></a>Generators</h2></div></div></div><p>
A value generator in JavaScript or Python is created using the <code class="code">client.MR.createValueGenerator(valueGeneratorOperator)</code>. <code class="code">valueGeneratorOperator</code> must be a value generator operator returned from <code class="code">client.KLC.createValueGeneratorOperator()</code> or <code class="code">executable.resolveValueGeneratorOperator()</code>. For example, the JavaScript code:
</p><pre class="programlisting">
    client.MR.createValueGenerator(
      client.KLC.createValueGeneratorOperator(
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"generate.kl"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"operator generate(io Scalar x) { x = 5.9; }"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"generate"</span>
      )
    ).produce();
</pre><p>
produces the output:
</p><pre class="screen">
    5.900000095367432
</pre><p>
An array generator in KL is created using the <code class="code">client.MR.createArrayGenerator(countValueGenerator, arrayGeneratorOperator)</code>. The <code class="code">countValueProducer</code> parameter must be a value producer that produces a value of type <code class="code">Size</code>. <code class="code">arrayGeneratorOperator</code> must be an array generator operator returned from <code class="code">client.KLC.createArrayGeneratorOperator()</code> or <code class="code">executable.resolveArrayGeneratorOperator()</code>. An example of an array generator:
</p><pre class="programlisting">
    client.MR.createArrayGenerator(
      client.MR.createConstValue(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">'Size'</span>, <span class="hl-number">1000000</span>),
      client.KLC.createArrayGeneratorOperator(
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"generate.kl"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"operator generate(io Scalar x, Index index) { x = 3.141 * index; }"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"generate"</span>
      )
    ).produce(<span class="hl-number">9876</span>, <span class="hl-number">16</span>);
</pre><p>
produces:
</p><pre class="screen">
    [ 31020.515625,
      31023.658203125,
      31026.798828125,
      31029.939453125,
      31033.080078125,
      31036.220703125,
      31039.36328125,
      31042.50390625,
      31045.64453125,
      31048.78515625,
      31051.92578125,
      31055.06640625,
      31058.208984375,
      31061.349609375,
      31064.490234375,
      31067.630859375 ]
</pre><p>
In both cases, you can optionally specify a shared value producer as the last parameter to the <code class="code">client.MR.create...Generator()</code> call. When a shared value producer is provided, the operator receives an additional parameter whose type is the value type of the shared value producer, as in KL.
</p></div><div class="section" title="Maps"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e453"></a>Maps</h2></div></div></div><p>
A value map in JavaScript or Python is created using the <code class="code">client.MR.createValueMap(inputValueProducer, valueMapOperator)</code>. <code class="code">inputValueProducer</code> must be a value producer, and <code class="code">valueMapOperator</code> must be a value map operator returned from <code class="code">client.KLC.createValueMapOperator()</code> or <code class="code">executable.resolveValueMapOperator()</code>. For example, the JavaScript code:
</p><pre class="programlisting">
    client.MR.createValueMap(
      client.MR.createConstValue(
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"String"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello, world!"</span>
      ),
      client.KLC.createValueMapOperator(
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"map.kl"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"operator map(String input, io Size output) { output = input.length; }"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"map"</span>
      )
    ).produce();
</pre><p>
produces the output:
</p><pre class="screen">
    13
</pre><p>
An array map in JavaScript or Python is created using the <code class="code">client.MR.createArrayMap(inputArrayProducer, arrayMapOperator)</code>. An example of an array map:
</p><pre class="programlisting">
    client.MR.createArrayMap(
      client.MR.createConstArray(
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"String"</span>,
        [<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Hello, world!"</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Goodbye, cruel world!"</span>]
      ),
      client.KLC.createArrayMapOperator(
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"map.kl"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"operator map(String input, io Size output) { output = input.length; }"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"map"</span>
      )
    ).produce();
</pre><p>
produces:
</p><pre class="screen">
    [ 13, 21 ]
</pre><p>
As in KL, you can optionally specify a shared value producer as the last parameter to the <code class="code">client.MR.create...Map()</code> call. When a shared value producer is provided, the operator receives an additional parameter whose type is the value type of the shared value producer, as in KL.
</p></div><div class="section" title="Transforms"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e471"></a>Transforms</h2></div></div></div><p>
A value transform in JavaScript or Python is created using the <code class="code">client.MR.createValueTransform(inputValueProducer, valueTransformOperator)</code>. The type of the first parameter of the operator must be the value type of the input producer. For example:
</p><pre class="programlisting">
    client.MR.createValueTransform(
      client.MR.createConstValue(
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"String"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Peter"</span>
      ),
      client.KLC.createValueTransformOperator(
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"trans.kl"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"operator trans(io String value) { value = 'Hello, ' + value + '!'; }"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"trans"</span>
      )
    ).produce();
</pre><p>
produces the output:
</p><pre class="screen">
    'Hello, Peter!'
</pre><p>
An array transform in JavaScript or Python is created using the <code class="code">client.MR.createArrayTransform(inputArrayProducer, arrayTransformOperator)</code>. The type of the first parameter of the operator must be the element type of the input producer. For example:
</p><pre class="programlisting">
    client.MR.createArrayTransform(
      client.MR.createConstArray(
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"String"</span>,
        [<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Peter"</span>,<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Fred"</span>,<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Joe"</span>]
      ),
      client.KLC.createArrayTransformOperator(
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"trans.kl"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"operator trans(io String value) { value = 'Hello, ' + value + '!'; }"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"trans"</span>
      )
    ).produce();
</pre><p>
produces:
</p><pre class="screen">
    [ 'Hello, Peter!',
      'Hello, Fred!',
      'Hello, Joe!' ]
</pre><p>
As in KL, you can optionally specify a shared value producer as the last parameter to the <code class="code">client.MR.create...Transform()</code> call. When a shared value producer is provided, the operator receives an additional parameter whose type is the value type of the shared value producer, as in KL.
</p></div><div class="section" title="Reduce"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e485"></a>Reduce</h2></div></div></div><p>
To create a reduce operation in JavaScript or Python, use the <code class="code">client.MR.createReduce(inputArrayProducer, reduceOperator)</code> call. <code class="code">inputArrayProducer</code> must be an array producer; assume its element type is <code class="code">InputType</code>. <code class="code">reduceOperator</code> must be a reduce operator with one of prototypes:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
<code class="code">operator operatorName(InputType input, io OutputType output)</code>
</p></li><li class="listitem"><p>
<code class="code">operator operatorName(InputType input, io OutputType output, Index index)</code>
</p></li><li class="listitem"><p>
<code class="code">operator operatorName(InputType input, io OutputType output, Index index, Size count)</code>
</p></li></ul></div><p>
The result of the <code class="code">client.MR.createReduce(...)</code> call is a value producer with value type <code class="code">OutputType</code>. For example:
</p><pre class="programlisting">
    client.MR.createReduce(
      client.MR.createConstArray(
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"String"</span>,
        [<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Peter"</span>,<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Fred"</span>,<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Joe"</span>]
      ),
      client.KLC.createReduceOperator(
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"reduce.kl"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"operator reduce(String input, io Size output) { output += input.length; }"</span>,
        <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"reduce"</span>
      )
    ).produce();
    client.close();
</pre><p>
produces the result:
</p><pre class="screen">
    12
</pre><p>
You can optionally specify a shared value producer as the last parameter to the <code class="code">client.MR.createReduce()</code> call. When a shared value producer is provided, the function receives an additional parameter whose type is the value type of the shared value producer. The prototype of the operator becomes:
</p><pre class="programlisting">
    operator reduce(InputType input, io OutputType output, Index index, Size count, SharedType sharedValue) {
      ...
    }
</pre><p>
Note that when using a shared value with an array map you must include the <code class="code">index</code> and <code class="code">count</code> parameters in the operator even if they are unused.
</p></div><div class="section" title="Caches"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e514"></a>Caches</h2></div></div></div><p>
To create a value cache in JavaScript or Python, use the <code class="code">client.MR.createValueCache(inputValueProducer)</code> call. The value type of the cache is the same as the value type of <code class="code">inputValueProducer</code>. Example usage:
</p><pre class="programlisting">
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> gen = 
      client.MR.createValueCache(
        client.MR.createValueGenerator(
          client.KLC.createValueGeneratorOperator(
            <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"xfo.kl"</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"operator xfo(io Integer value) { report('Running generator'); value = 121; }"</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"xfo"</span>
            )
          )
        );
    
    console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Should run generator"</span>);
    console.log(gen.produce());
    
    console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Should not run generator (cached)"</span>);
    console.log(gen.produce());
    
    gen.flush();
    console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Should run generator"</span>);
    console.log(gen.produce());
    
    client.close();
</pre><p>
results in:
</p><pre class="screen">
    Should run generator
    [FABRIC] [MT] Running generator
    121
    Should not run generator (cached)
    121
    Should run generator
    [FABRIC] [MT] Running generator
    121
</pre><p>
To create an array cache in JavaScript or Python, use the <code class="code">client.MR.createArrayCache(inputArrayProducer)</code> call. The element type of the resulting array provider is the same as the element type of <code class="code">inputArrayProducer</code>. Example usage:
</p><pre class="programlisting">
    cv = client.MR.createConstValue(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Size"</span>, <span class="hl-number">10</span>);
    
    ago = client.KLC.createArrayGeneratorOperator(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo.kl"</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"operator foo(io Scalar output, Index index) { report('Running generator'); output = sqrt(Scalar(index)); }"</span>, <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"foo"</span>);
    ag = client.MR.createArrayGenerator(cv, ago);
    
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> cache = client.MR.createArrayCache(ag);
    
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> count = ag.getCount();
    console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"cache.getCount() = "</span> + count);
    
    console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Should run generator"</span>);
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> (<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> i=<span class="hl-number">0</span>; i&lt;count; ++i)
      console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"cache.produce("</span>+i+<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">") = "</span>+cache.produce(i));
    
    console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Should not run generator (cached)"</span>);
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> (<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> i=<span class="hl-number">0</span>; i&lt;count; ++i)
      console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"cache.produce("</span>+i+<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">") = "</span>+cache.produce(i));
    
    cache.flush();
    console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"Should run generator"</span>);
    <span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">for</span> (<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-keyword">var</span> i=<span class="hl-number">0</span>; i&lt;count; ++i)
      console.log(<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">"cache.produce("</span>+i+<span xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:xslthl="http://xslthl.sf.net" xmlns:d="http://docbook.org/ns/docbook" class="hl-string">") = "</span>+cache.produce(i));
    
    client.close();
</pre><p>
results in:
</p><pre class="screen">
    cache.getCount() = 10
    Should run generator
    [FABRIC] [MT] Running generator
    cache.produce(0) = 0
    [FABRIC] [MT] Running generator
    cache.produce(1) = 1
    [FABRIC] [MT] Running generator
    cache.produce(2) = 1.414213538169861
    [FABRIC] [MT] Running generator
    cache.produce(3) = 1.732050776481628
    [FABRIC] [MT] Running generator
    cache.produce(4) = 2
    [FABRIC] [MT] Running generator
    cache.produce(5) = 2.2360680103302
    [FABRIC] [MT] Running generator
    cache.produce(6) = 2.449489831924438
    [FABRIC] [MT] Running generator
    cache.produce(7) = 2.645751237869263
    [FABRIC] [MT] Running generator
    cache.produce(8) = 2.828427076339722
    [FABRIC] [MT] Running generator
    cache.produce(9) = 3
    Should not run generator (cached)
    cache.produce(0) = 0
    cache.produce(1) = 1
    cache.produce(2) = 1.414213538169861
    cache.produce(3) = 1.732050776481628
    cache.produce(4) = 2
    cache.produce(5) = 2.2360680103302
    cache.produce(6) = 2.449489831924438
    cache.produce(7) = 2.645751237869263
    cache.produce(8) = 2.828427076339722
    cache.produce(9) = 3
    Should run generator
    [FABRIC] [MT] Running generator
    cache.produce(0) = 0
    [FABRIC] [MT] Running generator
    cache.produce(1) = 1
    [FABRIC] [MT] Running generator
    cache.produce(2) = 1.414213538169861
    [FABRIC] [MT] Running generator
    cache.produce(3) = 1.732050776481628
    [FABRIC] [MT] Running generator
    cache.produce(4) = 2
    [FABRIC] [MT] Running generator
    cache.produce(5) = 2.2360680103302
    [FABRIC] [MT] Running generator
    cache.produce(6) = 2.449489831924438
    [FABRIC] [MT] Running generator
    cache.produce(7) = 2.645751237869263
    [FABRIC] [MT] Running generator
    cache.produce(8) = 2.828427076339722
    [FABRIC] [MT] Running generator
    cache.produce(9) = 3
</pre></div></div></div></body></html>